{"meta":{"title":"Gxzblog","subtitle":"python advance","description":"Life is short, I enjoy python.","author":"Gxzblog","url":"https://github.com/Gyz-polymer/Gyz-polymer.github.io","root":"/Gyz-polymer.github.io/"},"pages":[],"posts":[{"title":"数据集dataSet","slug":"数据集dataSet","date":"2020-08-03T07:11:16.234Z","updated":"2020-08-03T07:33:47.296Z","comments":true,"path":"2020/08/03/数据集dataSet/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E9%9B%86dataSet/","excerpt":"","text":"数据集dataSet定义：为了计算需要的统计数据，如平均数，最大数，最小数，方差等，我们需要跟踪整组分数。在统计里，我们把这些分数称为数据集（dataset）。 功能： ❏ Dataset()创建一个空数据集。它不需要参数。❏ size()获取数据集的长度。它不需要参数。❏ add(item)给数据集添加一个数据。它需要一个参数：要添加的数据。❏ average()获取数据集的平均数。它不需要参数。❏ min()获取数据集的最小数。它不需要参数。❏ max()获取数据集的最大数。它不需要参数。❏ squares()获取数据集所有元素的平方和。它不需要参数。❏ sdev()获取数据集的统计方差。它不需要参数。怎样才能把数字输入到数据集（Dataset）里？最简单也最容易想到的就是利用列表或数组等保存数据，伪代码如下： 123456789101112131415161718192021222324class Dataset(object): \"\"\"Dataset is a collection of numbers from which simple descriptive statistics can be computed.\"\"\" def __init__(self): \"\"\"post: self is an empty Dataset\"\"\" def add(self, x): \"\"\"add x to the data set post: x is added to the data set\"\"\" def min(self): \"\"\"find the minimum pre: size of self &gt;= 1 post: returns smallest number in self\"\"\" def max(self): \"\"\"find the maximum pre: size of self &gt;= 1 post: returns largest number in self\"\"\" def average(self): \"\"\"calculate the mean pre: size of self &gt;= 1 post: returns the mean of the values in self\"\"\" def std_deviation(nums): \"\"\"calculate the standard deviation pre: size of self &gt;= 2 post: returns the standard deviation of the values in self\"\"\" 但是如上代码运行和逻辑上没有任何问题，但是在数据集超级大，含有千万上亿个元素时，造成的缓存就会很大，每次运行的时间也会随数据集长度的增加而线性增加，时间复杂度是O(n)。但是，所求的平均数，最大数等都不需要获取具体的数据，所以数据集可以只放结果和获取的接口而不存放具体的数据。 优化 封装：设计私有变量来存放统计数据的结果，设计单独的接口来获取私有变量 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from collections import dequeimport mathclass dataSet(object): def __init__(self): self._size = 0 self._average = None self._sum = 0 self._dmin = deque(maxlen=1) self._dmax = deque(maxlen=1) self._squares = 0 def add(self, item): self._size += 1 self._sum += item self._squares += item ** 2 self._average = self._sum / self._size if len(self._dmin) &lt; 1 or self._dmin[0] &gt; item: self._dmin.append(item) if len(self._dmax) &lt; 1 or self._dmax[0] &lt; item: self._dmax.append(item) def getSize(self): return self._size def getAverage(self): return self._average def getMin(self): return self._dmin[0] def getMax(self): return self._dmax[0] def getSquares(self): return self._squares def getSdev(self): return math.sqrt((self._squares - self._sum ** 2 / self._size) / (self._size - 1))newSet = dataSet()print(newSet.getSize()) #out: 0newSet.add(1)print(newSet.getSize()) #out: 1newSet.add(3)print(newSet.getSdev()) #out：1.4142135623730951print(newSet.getSquares()) #out：10print(newSet.getSize()) #out: 2newSet.add(5)newSet.add(6)newSet.add(9)print(newSet.getAverage()) #out：4.8print(newSet.getMin()) #out：1print(newSet.getMax()) #out：9 上面的代码引入了collections模块中的双端队列deque，用来限制缓存的长度，每次只保存一个元素。 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"有理数类","slug":"有理数类","date":"2020-08-03T05:41:11.270Z","updated":"2020-08-03T07:33:47.312Z","comments":true,"path":"2020/08/03/有理数类/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/03/%E6%9C%89%E7%90%86%E6%95%B0%E7%B1%BB/","excerpt":"","text":"有理数类在python中，含有小数的数字通常用float数据类型来表示。使用浮点数（float）的一个缺点是：底层存储方式只是一个近似值，而不是精确值。数字会首先被转换为二进制（基数2），因此不以2的幂作为分母的任何分数，都将会转换成具有无限循环的商。而当这个商数为了放进有限的存储器位置而被截断时，就会丢失一些精度。 解决办法：可以创建一个有理数类，专门存放小数来保存浮点数的完整性。 ❏ Rational(分子，分母)创建一个空列表。它接受两个参数，返回以字符串表示的分子，如1/2。❏ 实现Rational类实例对象之间的加减乘除操作，利用魔法函数实现。❏ 实现Rational类实例对象之间的大小比较，是否等于比较操作，利用魔法函数实现。❏ 实现分子分母约分，输出最简分数，利用欧几里得最大公约数算法实现。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Rational(object): # 构造函数：传入分子和分母 def __init__(self, num, den): ''' :param num: is interger :param den: is interger post: creates the Rational object num / den ''' self.num = num self.den = den # 分母不可以传入0 if den == 0: raise ValueError('分母不可以为0.') # 欧几里得算法求最大公约数：a 、b（a&gt;b）的最大公约数等于 b 和 a-b 的最大公约数。 def getGCD(self): x = self.num y = self.den while y: t = x % y x = y y = t return x # 在实例中使用加法 + def __add__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self + other ''' if self.den == other.den: num = self.num + other.num den = self.den else: num = self.num * other.den + self.den * other.num den = self.den * other.den return Rational(num, den) # 在实例中使用减法 - def __sub__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self + other ''' if self.den == other.den: num = self.num - other.num den = self.den else: num = self.num * other.den - self.den * other.num den = self.den * other.den return Rational(num, den) # 在实例中使用乘法 * def __mul__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self * other ''' num = self.num * other.num den = self.den * other.den return Rational(num, den) # 在实例中使用除法 / def __truediv__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self * other ''' num = self.num * other.den den = self.den * other.num return Rational(num, den) # 在实例中使用取负 - def __neg__(self): ''' :param other: self is Rational bojects :return: Rational result:self * other ''' num = - self.num den = self.den return Rational(num, den) # 小于＜比较，返回布尔值 def __lt__(self, other): return (self.num / self.den - other.num / other.den) &lt; 0 # 小于等于＜=比较，返回布尔值 def __le__(self, other): return (self.num / self.den - other.num / other.den) &lt;= 0 # 大于大于比较，返回布尔值 def __gt__(self, other): return (self.num / self.den - other.num / other.den) &gt; 0 # 大于等于=＞比较，返回布尔值 def __ge__(self, other): return (self.num / self.den - other.num / other.den) &gt;= 0 # 等于==比较，返回布尔值 def __eq__(self, other): return (self.num / self.den - other.num / other.den) == 0 # 等于==比较，返回布尔值 def __ne__(self, other): return (self.num / self.den - other.num / other.den) != 0 # 定义print打印的返回值 def __str__(self): ''' self is a Rational object :return: return a string represent self ''' # 获得最大公约数 gcd = self.getGCD() # 返回值去点后面的.0 if str(self.num / gcd).split('.')[0] and str(self.den / gcd).split('.')[0]: return str(self.num / gcd).split('.')[0] + '/' + str(self.den / gcd).split('.')[0] else: return str(self.num / gcd) + '/' + str(self.den / gcd) 应用: 输出埃及分数古埃及人只用真分数，而且分数都表示成不同的单位分数(也就是分子为1，分母为各不相同的正整数)的和。如： 3/4 = 1/2 + 1/4 7/8 = 1/2 + 1/3 +1/24 算法原理：不解释分子为1和分子和分母`是倍数关系的简单情况，说一下一般情况。对于7/8，分解的第一个单位分数的分母是2，也就是：8 % 7 + 1，可以设置一个变量为 value = 分子 % 分母 + 1，然后判断二者之差7/8 - 1/value的分子是不是等于1，如果是就解决了，如果不是就进行迭代：现在的传入分数是7/8 - 1/value，直到结果的分子都等于1. 代码实现： 12345678910111213141516171819202122232425262728def getEgyptianFraction(r): i = True while (i): if r.num &gt;= r.den: raise ValueError('分子不能大于分母。') elif r.num == 1: print(\"1/&#123;&#125;\".format(r.den)) i = False break elif r.den % r.num == 0: print(\"1/&#123;&#125;\".format(int(r.den / r.num))) i = False break else: value = int(r.den / r.num) + 1 print(\"1/&#123;&#125;\".format(value), end=\"+\") # 迭代 newR = Rational(r.num * value - r.den, value * r.den) return getEgyptianFraction(newR)r0 = Rational(500 ,488)getEgyptianFraction(r1) #out: ValueError: 分子不能大于分母。r1 = Rational(7 ,8)getEgyptianFraction(r1) #out: 1/2+1/3+1/24r2 = Rational(475 ,488) getEgyptianFraction(r2) #out: 1/2+1/3+1/8+1/67+1/9809+1/481072596 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"魔法方法","slug":"魔法方法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"}]},{"title":"单向链表 SingleLinkList","slug":"单向链表SingleLinkList","date":"2020-07-31T10:30:28.509Z","updated":"2020-08-03T05:24:51.788Z","comments":true,"path":"2020/07/31/单向链表SingleLinkList/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/31/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8SingleLinkList/","excerpt":"","text":"单向链表链表是线性表的链式存储方式。逻辑上相邻的数据在计算机内的存储位置不一定相邻。链表的存储方式：通过节点Node储存数据。 每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个节点的地址，因此指针指向的类型也是节点类型。每个指针都指向下一个节点，都是朝一个方向的，这样的链表称为单向链表或单链表。 单链表的初始化是指构建一个空表。先创建一个头节点，不存储数据，然后令其指针域为空。 链表的一般特点：❏ SingleLinkList()创建一个空链表。它不需要参数，且会返回一个空列表。 ❏ add(item)向链表头部添加item。它接受一个元素作为参数，无返回值。 ❏ remove(item)从链表中移除item。它接受一个元素作为参数，并且修改列表。 ❏ search(item)在链表中搜索元素item。它接受一个元素作为参数，并且返回布尔值。 ❏ travel()打印整个链表，不需要参数。 ❏ isEmpty()检查列表是否为空。它不需要参数，并且返回布尔值。 ❏ length()返回列表中元素的个数。它不需要参数，并且返回一个整数。 ❏ append(item)在列表的尾部添加item。它接受一个元素作为参数，无返回值。 ❏ index(item)返回该元素在列表中的位置。它接受一个元素作为参数，并且返回该元素的下标(下标从0开始)。 ❏ insert(pos, item)假设元素item之前不在列表中，同时假设pos是合理的值，并在位置pos处添加元素item。它接受两个参数，无返回值。 ❏ pop()移除列表中的最后一个元素。它不需要参数，且会返回一个元素。 ❏ pop(pos)移除该位置上的元素。它接受位置参数，且会返回一个元素。 利用python实现单向链表创建链表节点Node类每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个节点的地址。 12345678910111213class Node: def __init__(self, data): self.data = data # 将初始值设为None self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newdata): self.data = newdata def setNext(self, newNext): self.next = newNext 创建单向链表单向链表类本身并不包含任何节点对象，而只保存了指向列表头部的第一个节点的引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&gt;class SingleLinkList: def __init__(self): # 列表初始化时并没有元素，所有引用也为空 self.head =None # 检查列表是否为空，只需要检查列表中头部的引用是否位None就可以，因为如果头部为空后面也是空 def isEmpty(self): # 布尔表达式self.head == None当且仅当链表中没有节点时才为真。 return self.head == None # 获取链表长度 def length(self): current = self.head # current是外部引用，被初始化为头节点 count = 0 while current != None: # None是最后一个节点的引用 count += 1 current = current.getNext() return count # 搜索链表 def search(self, item): current = self.head # 将查询结构记录在found中 found = False while current != None and not found: if current.getData() == item: found = True else: current = current.getNext() return found # 遍历链表 def travel(self): current = self.head while current != None: print(current.data, end='=&gt;') current = current.getNext() # 增加一个换行 print() # 搜索某个元素,返回位置，从0开始，如果没有返回None def index(self, item): current = self.head # 如果找到了元素 if self.search(item): count = 0 while current.getData() != item: count += 1 current = current.getNext() return count # 链表头部增加元素，元素的位置无所谓，重要的是方便和指引下一个元素 def add(self, item): # 创建一个新的结点 node = Node(item) # 将新结点的下一个元素设置为头节点 node.setNext(self.head) # 修改新节点为头节点 self.head = node # 向链表尾部添加元素 def append(self, item): # 创建一个新的结点 node = Node(item) # 先判断是否为空链表 if self.isEmpty(): self.head = node # 若链表不为空 else: current = self.head # 遍历到倒数第二个节点的引用 while current.getNext() != None: current = current.getNext() # 当current时最后一个元素时,把新节点放在其后面 current.setNext(node) # 向链表任意位置插入元素 def insert(self, pos, item): # 如果pos小于0，则在头部加入 if pos &lt; 0: self.add(item) # 如果pos大于列表长度就在尾部添加 elif pos &gt; self.length()-1: self.append(item) # 在中间添加元素时 else: # 创建一个新节点 node = Node(item) current = self.head index = 0 while index &lt; pos - 1: current = current.getNext() index += 1 # 当index=pos-1时,获取下一个节点 next = current.getNext() # 将新节点插入 current.setNext(node) # 新节点的下一个位置设为next节点 node.setNext(next) # remove方法：先查找找到再删除，既要删除节点也要删除引用 def remove(self, item): current = self.head # previous指向上一次访问的节点 previous = None found = False # 先找到元素 while not found: if current.getData() == item: found = True else: previous = current current = current.getNext() # 当current是第一个元素时 if previous == None: self.head = current.getNext() # 最后一个元素也适用，下一个就是None else: previous.setNext(current.getNext()) # 删除最后一个元素 def pop(self,*pos): #如果链表非空 if self.head: current = self.head index = 0 # 参数*pos是一个元组，没有传入位置pos if not len(pos): # 找到倒数第二个元素的引用 while current.getNext().getNext() != None: current = current.getNext() # 设置最后一个元素为None current.setNext(None) # 如果传入了位置pos else: # 获取元组第一个参数，也是唯一的参数 while index &lt; pos[0] - 1: current = current.getNext() index += 1 # 当找到位置时,跳过当前元素 current.setNext(current.getNext().getNext())&gt;ulist = SingleLinkList()&gt;print(ulist.isEmpty()) #out: True&gt;ulist.add('a') #out: False&gt;ulist.travel() #out: a=&gt;&gt;print(ulist.isEmpty()) #out: False&gt;ulist.add('b')&gt;ulist.add('c')&gt;ulist.add('d')&gt;ulist.travel() #out: d=&gt;c=&gt;b=&gt;a=&gt;&gt;print(ulist.search('a')) #out: True&gt;print(ulist.index('b')) #out: 2&gt;ulist.remove('a')&gt;print(ulist.search('a')) #out: False&gt;ulist.travel()&gt;ulist.append('w') #out: d=&gt;c=&gt;b=&gt;&gt;ulist.travel()&gt;ulist.insert(2,'v') #out: d=&gt;c=&gt;b=&gt;w=&gt;&gt;ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;w=&gt;&gt;ulist.pop()&gt;ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;&gt;ulist.pop()&gt;ulist.travel() #out: d=&gt;c=&gt;v=&gt;&gt;ulist.pop(1)&gt;ulist.travel() #out:d=&gt;v=&gt; 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"双端队列 Deque","slug":"双端队列Deque","date":"2020-07-30T05:01:55.864Z","updated":"2020-08-03T05:23:11.086Z","comments":true,"path":"2020/07/30/双端队列Deque/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/30/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97Deque/","excerpt":"","text":"双端队列deque双端队列是与队列类似的有序集合。它有一前、一后两端，元素在其中保持自己的位置。 与队列不同的是，双端队列对在哪一端添加和移除元素没有任何限制。新元素既可以被添加到前端，也可以被添加到后端。同理，已有的元素也能从任意一端移除。 某种意义上，双端队列是栈和队列的结合。 注意，不要把它的英文名deque（与deck同音）和队列的移除操作dequeue搞混了。 python实现双端队列的两种方式： 1.自定义双端队列12345678910111213141516# 假设双端队列的尾部是列表的头部[0]class Deque: def __init__(self): self.items = [] def addFront(self, item): self.items.insert(0,item) def addRear(self, item): self.items.append(item) def removeFront(self): return self.items.pop() def removeRear(self): return self.items.pop(0) def isEmpty(self): return self.items == [] def size(self): return len(self.items) 2. 也可以从collections模块中引入123456789101112131415161718192021from collections import dequed = deque()# 增加数据d.append('1')d.append('2')d.append('3')print(len(d),d[0],d[-1])f = deque(range(5))print(len(f))#两端删除数据print(f.popleft()) # 删除左端第一个数据print(f.pop()) # 删除右端第一个数据f.extend([6]) # 右端可增加数据,必须是可迭代数据，如列表，元组，集合setf.extendleft((8,)) # 左端增加数据f.extendleft(&#123;9&#125;) # 左端增加数据print(f)# 设定队列长度e = deque([0, 1, 2, 3, 5], maxlen=5)e.extend([2,3])print(e) # 输出：deque([2, 3, 5, 2, 3], maxlen=5) 应用：回文检测回文就是正向和反向读都一样的句子或单词：radar，假似真时真似假 人欺我处我欺人。 可以利用双端队列的双重性，其前端是字符串的第一个字符，后端是字符串的最后一个字符。123456789101112131415161718#回文检测def checker(string): check = Deque() # 将字符串中每一个字符添加到双端队列 for each in string: check.addRear(each) # 加一个flag，判断是否继续进行首尾对比 stillEqual = True # 区分字符串奇偶：长度 为0或1就停止比较 while check.size() &gt; 1 and stillEqual: first = check.removeFront() last = check.removeRear() if first != last: stillEqual = False return stillEqualprint(checker('lool')) # Trueprint(checker('look')) # False 也可以利用双端队列的特点生成回文：12345678910111213141516171819# 生成回文---可传入中文或英文单词def genPalindrome(string): pad = Deque() # 反转一下字符串 for each in reversed(string): pad.addRear(each) # 最后一个字符不能加两次 for each in reversed(string[:-1]): pad.addFront(each) # 创建一个列表用于保存结构 result = [] for i in range(pad.size()): each = pad.removeFront() result += each result = ''.join(result) return resultprint(genPalindrome('我很开心')) # out: 我很开心开很我print(genPalindrome('hello')) # out: hellolleh 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"队列 Queue","slug":"队列Queue","date":"2020-07-30T03:01:20.803Z","updated":"2020-08-03T05:24:51.848Z","comments":true,"path":"2020/07/30/队列Queue/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/30/%E9%98%9F%E5%88%97Queue/","excerpt":"","text":"队列dequedeque是一种线性数据结构，具有先进先出First In First Out,后进后出的特点。只允许一头进(添加操作)–顶端，另一头出(移除操作)–底端。 队列：生活中排队买东西，先来的先买，后到的后买 用python实现队列： 用列表实现队列，队列的尾部在列表头部，队列头部在列表尾部 12345678910111213141516&gt;class Queue: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.insert(0,item) def dequeue(self): return self.items.pop() def size(self): return len(self.items) &gt;q = Queue()&gt;print(q.isEmpty()) # True&gt;q.enqueue('bobby')&gt;print(q.isEmpty()) # False 用列表实现队列，队列的头部在列表头部，队列尾部在列表尾部 1234567891011class QueueLeft: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def size(self): return len(self.items) 应用：约瑟夫问题一个游戏：每隔几个人移除一个人，如每数到7去掉一人 1234567891011121314def CountNum(nameArr,num): qu = Queue() for name in nameArr: # 在队列中名字顺序反过来了，刚好因为出栈顺序是先进先出 qu.enqueue(name) # 如果队列中人数多余一人，继续移除 while qu.size() &gt; 1: for i in range(num): # 移除队列的人马上从另一端重新加入队列 qu.enqueue(qu.dequeue()) # 每个num个人移除一个 qu.dequeue() return qu.dequeue()print(CountNum(['a','b','v','d','f','h','w','k','l','o','q'],7)) #out:l 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈 Stack","slug":"栈Stack","date":"2020-07-29T14:05:11.206Z","updated":"2020-08-03T05:24:51.828Z","comments":true,"path":"2020/07/29/栈Stack/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/%E6%A0%88Stack/","excerpt":"","text":"栈stackstack是一种数据结构，具有先进后出First In Last Out,后进先出的特点。只允许一头进出(添加操作)–顶端，(移除操作)–顶端，底端不发生变化。 就像在自助餐厅的一摞盘子，最上面的盘子是最后加上去的，但是总是最先被取走使用，这就是后进先出。 栈操作：❏ push(item)将一个元素添加到栈的顶端。它需要一个参数item，且无返回值。❏ pop()将栈顶端的元素移除。它不需要参数，但会返回顶端的元素，并且修改栈的内容。❏ peek()返回栈顶端的元素，但是并不移除该元素。它不需要参数，也不会修改栈的内容。❏ isEmpty()检查栈是否为空。它不需要参数，且会返回一个布尔值。❏ size()返回栈中元素的数目。它不需要参数，且会返回一个整数。利用python实现栈： 利用列表，假设列表的尾部是栈的头部 1234567891011121314151617181920212223242526272829# 实现栈Last In first Out的功能：push，pop,peek,isEmpty,size()# 用列表实现，假设列表的尾部是栈的顶端class Stack: def __init__(self): self.items = [] # 判断栈是不是空的 def isEmpty(self): return self.items == [] # 将元素添加到栈的顶端 def push(self,item): self.items.append(item) # 时间复杂度O(1) # 将元素从栈的顶端移除 def pop(self): return self.items.pop() # 时间复杂度O(1) # 返回栈顶端的数据 def peek(self): return self.items[len(self.items)-1] # 返回栈的大小 def size(self): return len(self.items)s1 = Stack()print(s1.isEmpty())s1.push(1)print(s1.isEmpty())s1.push(2)print(s1.peek())print(s1.size())print(s1.items) 利用列表，假设列表的头部是栈的头部 123456789101112131415161718class StackRight: def __init__(self): self.items = [] # 判断栈是不是空的 def isEmpty(self): return self.items == [] # 将元素添加到栈的顶端 def push(self,item): self.items.insert(0,item) # 时间复杂度O(n) # 将元素从栈的顶端移除 def pop(self): return self.items.pop(0) # 时间复杂度O(n) # 返回栈顶端的数据 def peek(self): return self.items[0] # 返回栈的大小 def size(self): return len(self.items) 应用：栈先进后出的特点有很多巧妙的应用 1.判断符号的匹配，python种表示[]列表，()表示元组，{}表示字典或集合，这些符号都是可以复用的，组合使用，如{[()()&lt;&gt;()]}是一个符合匹配的形式，而([)]，{([}不不符合匹配。利用栈可以判断是否符合匹配 1234567891011121314151617181920212223242526272829# 利用上面列表的尾部是栈的顶端---第一种方法实现栈def parChecker(pars): s = Stack() balanced = True index = 0 while index &lt; len(pars) and balanced: par = pars[index] if par in '&lt;(&#123;[': s.push(par) # 如果不是开始符号 else: if s.isEmpty(): # 说明closed的符号多了 balanced = False else: top = s.pop() # 获得弹出的符号 if not matches(top, par): # 判断弹出符号与当前的是否匹配 balanced = False index += 1 if balanced and s.isEmpty(): return True else: return Falsedef matches(start,close): # 判断是否匹配 starts = '&lt;(&#123;[' closes = '&gt;)&#125;]' # index获取字符在字符串中的位置 return starts.index(start) == closes.index(close)print(parChecker('&#123;[()()&lt;&gt;()]&#125;')) # out:Trueprint(parChecker('&#123;[()(&lt;&gt;()]&#125;')) # out:False 2.进制转换：十进制转换为二进制，一般转化成二进制是通过除以2的方法实现。 ​ 算法实现： 1234567891011121314# 利用上面列表的尾部是栈的顶端---第一种方法实现栈def divideBy2(decNumber): # c参数是十进制数字 remStack = Stack() while decNumber &gt; 0: rem = decNumber % 2 # 取余数并推入到栈里 remStack.push(rem) decNumber = decNumber // 2 binString = '' while not remStack.isEmpty(): binString = binString + str(remStack.pop()) # 从栈中弹出一位数添加到字符串中 return binStringprint(divideBy2(16)) #out:10000print(divideBy2(17)) #out:10001 ​ 进一步：实现多种进制的转换 1234567891011121314def divideByBase(decNumber,base): # base为要转化为的进制 # 创建一套可以表示16进制的字符 digits = '0123456789ABCDEF' remStack = Stack() while decNumber &gt; 0: rem = decNumber % base # 取余数作为最后一位 remStack.push(rem) decNumber = decNumber // base baseString = '' while not remStack.isEmpty(): baseString = baseString + str(remStack.pop()) return baseStringprint(divideByBase(16,16)) #转化为16进制，10print(divideByBase(32,8)) # 转化为8进制，40 3.中序，前序，后续表达式转换 对于A+B×C+D人类可以根据运算符优先级进行步骤计算：先算括号，再算乘除，最后加减。但是计算机并不认识加减乘除，必须加上括号才能识别优先级，前面的优先级就要写成：(A+(B×C)+D)，平白多了两对括号，为了解决这个问题就引入了前序和后续表达式，如下所示： 中序表达式 前序表达式 后序表达式 A + B + A B A B + A + B × C + A * B C A B C * + 若要将任意复杂的中序表达式转换成前序表达式或后序表达式，可以先将其写作完全括号表达式，然后将括号内的运算符移到左括号处（前序表达式）或者右括号处（后序表达式）。 只有中序表达式需要额外的符号来消除歧义。前序表达式和后序表达式的运算顺序完全由运算符的位置决定。鉴于此，中序表达式是最不理想的算式表达法。 算法实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 将中序表达式转化为后序表达式import stringdef infixToPostfix(infixexpr): # infixexpr：输入的表达式字符之间一定要有空格 prec = &#123;&#125; # 用数字表示运算符的优先级 prec['*'] = 3 prec['/'] = 3 prec['+'] = 2 prec['-'] = 2 prec['('] = 1 # 用于保存输入表达式中的所有运算符 newStack = Stack() # 列表保存结果：生成后续表达式 postFixList = [] # 将输入的表达式通过空格转换成列表 tokenList = infixexpr.split() #检查输入的表达式是否符合每个字符间有空格 for token in tokenList: if len(token) != 1: return '输入的表达式字符之间缺少空格...' # 对生成的列表逐个扫描 for token in tokenList: # 用所有大写字母表示表达式中所有可以出现的操作数 if token in string.ascii_uppercase: # 如果是操作数(A,B,C...)就加到列表末尾 postFixList.append(token) # 如果是左括号就压入栈 elif token == '(': newStack.push(token) # 如果是右括号就弹出栈，直到找到与之对应的左括号 elif token == ')': topToken = newStack.pop() while topToken != '(': # 把从栈中取出来的运算符都添加到列表末尾 postFixList.append(topToken) topToken = newStack.pop() # 如果是其他运算符 * / + - 就把运算符压入栈 else: # 压入之前，先判断：如果栈中的运算符优先于输入的运算符，就把栈中的运算符添加到列表末尾 while (not newStack.isEmpty()) and (prec[newStack.peek()] &gt;= prec[token]): postFixList.append(newStack.pop()) newStack.push(token) # 处理完所有输入后，将栈中残留的运算符全部添加到列表末尾 while not newStack.isEmpty(): postFixList.append(newStack.pop()) # 把列表变成字符串 return ' '.join(postFixList)print(infixToPostfix('A + B * C')) #out: A B C * +# 在A与+之间删除空格print(infixToPostfix('A+ B * C')) #out: 输入的表达式字符之间缺少空格... 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"垃圾回收和缓存机制","slug":"python垃圾回收和缓存机制","date":"2020-07-29T08:42:04.290Z","updated":"2020-08-03T05:24:51.798Z","comments":true,"path":"2020/07/29/python垃圾回收和缓存机制/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收机制一句话python垃圾回收：以引用计数为主，标记清除和分代回收为辅。引用计数器环状双向链表：refchain—-python中创建的任意对象，都会加到refchain的双向链表中—包含了所有的python对象 针对代码name = &#39;bobby&#39;, 底层c语言会创建如下4个数据： 上一个对象的指针 *_ob_prev和下一个对象的指针 *_ob_next(_Py_HEAD_EXTRA)—双向查找 数据的类型 ob_refcnt：如int,str,float等 引用计数 *ob_type。此时引用计数是1，如果再让new = name,则引用计数变为2。 每一个对象都有至少这四个值,这四个值存放在结构体PyObject 里。 由多个元素组成的对象，如字典，列表，集合等还有一个值ob_size，用来存储数据大小(元素的个数)。 除PyObject之外，Python中另一个重要的是PyVarObject了，它是变长对象，例如List、String，显然PyObject无法满足它们需求，所以就需要用到PyVarObject了，实际上，PyVarObject与PyObject相比只多了一个属性ob_size，它指明了变成对象中有多少个元素（不是字节数） c++中两个重要的结构体：PyObject 和PyVarObject就是上述这个作用。 举例：创建一个float的内部实现 12345678data = 3.14# 内部会创建_ob_next = refchain的下一个对象_ob_prev = refchain的上一个对象ob_refcnt = 1 # 默认是1，当有其他变量引用时，引用计数发送变化 del则减一，当引用为0时则进行对象回收ob_type = floatob_fval = 3.14# 回收：将对象从refchain中移除，将对象进行销毁，归还对象所占用的内存 python会根据数据类型的不同，找到其对应的结构体，根据结构体中的字段来创建相关的数据，然后将对象添加到refchain双向链表中。当引用为0时就当成垃圾删除 引用计数器的bug：循环引用12345678t1 = [1,2,3] #refchain创建一个列表，列表的引用计数为1t2 = [4,5,6] #refchain再创建一个列表，列表的引用计数为1t1.append(t2) # t2被追加到t1，则t2对应的对象[4,5,6]的引用计数器加1，变为2t2.append(t1) # t1被追加到t2，则v1对应的对象[1,2,3]的引用计数器加1，变为2del t1 # 引用计数器-1，还是1，无法回收del t2 # 引用计数器-1，还是1，无法回收# 但是，此时没有变量指向[1,2,3]和[4,5,6]这两个列表了，变成一直存在于内存中的垃圾 标记清除目的：解决循环引用实现：再python底层再维护一个链表，在链表中专门放那些可能存在循环引用的对象(能存放其他对象的对象)，如list,dict,tuple,set等。 在python内部某种情况下去扫描这个可能循环引用的链表，检查是否有循环引用，如果有就让双方的引用计数器都减1，如果计数器是0就垃圾回收。 因此，python就有了两个链表。 问题来了： 什么时候扫描？ 扫描的代价：每次不仅要扫描可能有循环引用的对象，还要扫描其子元素是否有循环引用！ 扫描的代价很大，每次全部扫描成本很高，频繁扫描严重消耗性能，所以引入了对象分代机制。 分代回收实现：将可能存在循环引用的对象维护成3个链表： 0代链表：规定0代中对象个数达到700个就扫描1次。 1代链表：规定0代扫描10次，1代扫描1次。 2代链表：规定1代扫描10次，2代扫描1次。 最开始可能有循环引用的对象都将添加到0代，直到达到了700个，就进行1次扫描，如果有循环引用就计数器都减1，回收垃圾，如果没有，接下来的对象就添加到1代链表,如果再满了，就加到2代链表。 缓存机制池为了避免重复去创建和销毁常见对象，将常见对象(int,str)放在了一个池里，也就是说池里的对象永远不会被回收。 1234567# python内部会创建从-5到257的值，放在池里，所以创建t1 = 3时，不会重新开辟内存，直接从池里拿# int的数据池也被称为小数据池small_intst1 = 3t2 = 6t3 = 3 #t3和t1指向的内存地址一模一样--id(t3) == id(t1)t4 = 300 # 会重新创建对象t5 = 300 # 也会重新创建对象,t5与t4内存地址不同--id(t4) != id(t5) 对于字符串str类型，内部将所有的ASCII字符缓存到了unicode_latin[256]链表中，以后不用再反复创建。 12345s1 = 'C'print(s1) #out:1343834377264del s1s2 = 'C'print(s2) #out:1343834377264 s1和s2用的是同一个id地址 字符串驻留机制：对于只有字符，数字，下划线且长度不大于20的字符串，会缓存到内存中，再次创建一模一样的字符串时，不会再次开辟内存，而是直接从内存中取出来。 12345s1 = 'abcde'print(id(s1)) #out:1996598711216del s1s2 = 'abcde'print(id(s2)) #out:1996598711216 free_list链表当一个对象(float,list,dict,tuple)的引用计数器为0时，按理说应该回收，但内部不直接回收，而是放到free_list链表中当作缓存，下次再创建相同类型的对象时就不用重新开辟内存了，而是直接使用free_list链表。 1234pie = 3.14 # 创建float类型对象，开辟内存，添加到refchain中del pie # 从refchain移除，添加到free_list中# 再次创建float类型t2 = 6.88 # 不会重新开辟内存，从free_list中获取对象，对象数据初始化再放到refchain中。 但不是所以数据都缓存到free_list中，而是有数量限制，假设只能放100个对象，超过了100就会删除最先添加的对象。 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"判断异序字符串","slug":"判断异序字符串","date":"2020-07-29T04:00:31.367Z","updated":"2020-08-03T05:24:51.767Z","comments":true,"path":"2020/07/29/判断异序字符串/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/%E5%88%A4%E6%96%AD%E5%BC%82%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"需求判断两个单词是不是异序词，判断时忽略大小写，例如earth和heart就是异序词。以如下两个随便写的字符串为例，进行判断：12a = 'adceWq'b = 'aCedqw' 1.利用内置函数sorted：先判断长度，字母都变成小写，进行排序判断 – O(n^2)123456def sort_word(a,b): if len(a) == len(b) and sorted(a.lower()) == sorted(b.lower()): return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b) else: return 'No...'print(sort_word(a,b)) 2.清点法：将a的每一个字母添加到一个列表,如果b某一个字母不在a里面那就是不同字母 –O(n^2)12345678def justify(a,b): if len(a) == len(b): for i in b.lower(): if i not in list(a.lower()): return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)print(justify(a,b)) 3.蛮力法：将a生成所有的可能的字符串列表，看b是不是在里面—特别慢 O(n!)123456c = [[b1,b2,b3,b4,b5,b6] for b1 in a.lower() for b2 in a.lower().replace(b1,'') for b3 in a.lower().replace(b1,'').replace(b2,'') for b4 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'') for b5 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'') for b6 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'').replace(b5,'')]# print(c)if list(b.lower()) in c: print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)) 本来要将上面的方法简化一下，写成函数，函数恐怕也只能迭代了，迭代的速度也很低，没找到好方法，欢迎大家提供，这个方法其实是把问题变成了另一个问题：一个length为n的字符串随机排列的可能性，第一个字母有n中可能，第二个字母有n-1种可能性，所以一共就是1到n的累加种可能性：n*(n+1)/24.计数法：自己写一个或者利用collections的Counter模块123456789101112131415161718192021def count(a,b): # 先建立两个含有26个0的列表用来计数每个字母出现了几次 l1 = [0] * 26 l2 = [0] * 26 for i in range(len(a)-1): # a 对应数字97，以a为基准 pos = ord(a.lower()[i]) - ord('a') l1[pos] += 1 for i in range(len(b)-1): pos = ord(b.lower()[i]) - ord('a') l2[pos] += 1 # 判断生成的两个列表是否一样 for i in range(27): if l1[i] != l2[i]: return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a, b)from collections import Counterif Counter(a.lower()) == Counter(b.lower()): print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b))print(count(a,b)) 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"glob文件操作","slug":"glob模块","date":"2020-07-28T08:02:57.792Z","updated":"2020-08-03T05:24:51.808Z","comments":true,"path":"2020/07/28/glob模块/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/glob%E6%A8%A1%E5%9D%97/","excerpt":"","text":"glob模块:查找文件和目录可使用的通配符： *匹配0或多个字符 ** 匹配所有文件,目录，子目录和子目录里面的文件 ？ 匹配一个字符,这里与正则表达式? (正则?匹配前面表达式0次或者1次) [] 匹配指定范围内的字符,如: [1-9]匹配1至9内的字符 [!] 匹配不在指定范围内的字符 查找当前路径下所有py文件：12for fname in glob.glob(\"**/*.py\",recursive=True): # recursive=True也查找子文件夹中的文件 print(fname) 当前路径文件tmp下py文件:12for fname in glob.glob(\"./tmp/*.py\"): print(fname) 当前路径文件下以file开头后有一个字符的py文件:12for fname in glob.glob(\"./file?.py\"): print(fname) 当前路径文件下以file开头后一个数字符的py文件:12for fname in glob.glob(\"./file[0-9].py\"): print(fname) 当前路径文件下以file开头后一个非数字符的py文件:12for fname in glob.glob(\"./file[!0-9].py\"): print(fname) 查询子目录：12for name in glob.glob('dir/*/*'): print ('\\t', name) glob模块iglob 返回iterator执行效率更高:当前路径文件tmp下py文件:12for fname in glob.iglob(\"./tmp/*.py\"): print(fname) ## 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"}]},{"title":"python statistics模块","slug":"python数学统计","date":"2020-07-28T06:11:27.486Z","updated":"2020-08-03T05:24:51.818Z","comments":true,"path":"2020/07/28/python数学统计/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/python%E6%95%B0%E5%AD%A6%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"统计模块statistics statistics.mean(data) ：平均值，可输入列表，含小数的decimal statistics.harmonic_mean(data): 调和平均数(倒数平均数) statistics.median(data)： 中值 median([1, 3, 5, 7]) =&gt; 4 statistics.median_low(data)：小中值 median_low([1, 3, 5, 7]) =&gt; 3 statistics.median_high(data)：大中值 median_low([1, 3, 5, 7]) =&gt; 5 statistics.median_grouped(data, interval=1)：用组距式来求中位数 statistics.mode(data): 众数 statistics.pstdev(data, mu=None): 总体标准差 statistics.pvariance(data, mu=None): 总体方差 statistics.stdev(data, xbar=None): 样本标准差 statistics.variance(data, xbar=None): 样本方差 总体方差的分母却是n。样本方差的分母是n-1。 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"javascript原型链","slug":"js原型链","date":"2020-07-28T06:06:51.928Z","updated":"2020-08-03T05:24:51.777Z","comments":true,"path":"2020/07/28/js原型链/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/js%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"javascript原型原型链：每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。概念： prototype:每一个函数都有这个属性，指向函数的原型对象； __proto__:每一个 new 出来的对象都有这个属性，指向这个对象的原型(prototype )； constructor:每一个原型都有一个constructor属性，指向关联的构造函数 关键：原型对象也是一个对象，也有自己的\\proto__属性，所以就形成了继承链。相关： 在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。 ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数： 123456var a = &#123;a: 1&#125;; // a ---&gt; Object.prototype ---&gt; null var b = Object.create(a);// b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.a); //b的原型对象就是a javascript是没有真正意义上的类的，所谓的类就是基于原型链和继承来实现的，即使ES6中加入了class,extends关键字实现类和继承，但实际上还是基于原型链和继承， ES6 类（class）是 JavaScript 现有的原型继承的语法糖。 实际上在定义一个对象的时候原型链本身就已经生成了，javascript处处皆对象的思想放在这里理解起来就很容易了，看完后你会发现万物始于Object.prototype。 ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 class, constructor, static, extends, 和 super. 语法糖就相当于汉语里的成语。即，用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率。 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"}]},{"title":"jQuery的引入","slug":"jQuery","date":"2020-07-28T06:01:33.445Z","updated":"2020-08-03T05:24:51.838Z","comments":true,"path":"2020/07/28/jQuery/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/jQuery/","excerpt":"","text":"jQuery 引入jQuery1234路径引入&lt;script src='文件路径'&gt;&lt;/script&gt;引入在线资源&lt;script src = \"https://code.jquery.com/jquery-1.12.4.js\"&gt;&lt;/script&gt; 入口函数123456$(document).ready(function()&#123; //类似于原生js的window.onload&#125;);//简写$(function()&#123; &#125;); 实例 12345678$(\"td\").hover( function () &#123; $(this).addClass(\"hover\"); &#125;, function () &#123; $(this).removeClass(\"hover\"); &#125;); 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"},{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"魔法方法","slug":"魔法方法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"}]}