{"meta":{"title":"Gxzblog","subtitle":"python advance","description":"Life is short, I enjoy python.","author":"Gxzblog","url":"https://github.com/Gyz-polymer/Gyz-polymer.github.io","root":"/Gyz-polymer.github.io/"},"pages":[],"posts":[{"title":"垃圾回收和缓存机制","slug":"python垃圾回收和缓存机制","date":"2020-07-29T08:42:04.290Z","updated":"2020-07-29T08:50:38.817Z","comments":true,"path":"2020/07/29/python垃圾回收和缓存机制/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收机制一句话python垃圾回收：以引用计数为主，标记清除和分代回收为辅。引用计数器环状双向链表：refchain—-python中创建的任意对象，都会加到refchain的双向链表中—包含了所有的python对象 针对代码name = &#39;bobby&#39;, c语言会创建如下4个数据： 上一个对象的指针 *_ob_prev和下一个对象的指针 *_ob_next(_Py_HEAD_EXTRA)—双向查找 数据的类型 ob_refcnt：如int,str,float等 ``引用计数 *ob_type。此时引用计数是1，如果再让new = name,则引用计数变为2。每一个对象都有至少这四个值,这四个值存放在结构体PyObject` 里。 由多个元素组成的对象，如字典，列表，集合等还有一个值ob_size，用来存储数据大大小(元素的个数)。 除PyObject之外，Python中另一个重要的是PyVarObject了，它是变长对象，例如List、String，显然PyObject无法满足它们需求，所以就需要用到PyVarObject了，实际上，PyVarObject与PyObject相比只多了一个属性ob_size，它指明了变成对象中有多少个元素（不是字节数） c++中两个重要的结构体：PyObject 和PyVarObject就是上述这个作用。 举例：创建一个float的内部实现 12345678data = 3.14# 内部会创建_ob_next = refchain的下一个对象_ob_prev = refchain的上一个对象ob_refcnt = 1 # 默认是1，当有其他变量引用时，引用计数发送变化 del则减一，当引用为0时则进行对象回收ob_type = floatob_fval = 3.14# 回收：将对象从refchain中移除，将对象进行销毁，归还对象所占用的内存 python会根据数据类型的不同，找到其对应的结构体，根据结构体中的字段来创建相关的数据，然后将对象添加到refchain双向链表中。当引用为0时就当成垃圾删除 引用计数器的bug：循环引用12345678t1 = [1,2,3] #refchain创建一个列表，列表的引用计数为1t2 = [4,5,6] #refchain再创建一个列表，列表的引用计数为1t1.append(t2) # t2被追加到t1，则t2对应的对象[4,5,6]的引用计数器加1，变为2t2.append(t1) # t1被追加到t2，则v1对应的对象[1,2,3]的引用计数器加1，变为2del t1 # 引用计数器-1，还是1，无法回收del t2 # 引用计数器-1，还是1，无法回收# 但是，此时没有变量指向[1,2,3]和[4,5,6]这两个列表了，变成一直存在于内存中的垃圾 标记清除目的：解决循环引用实现：再python底层再维护一个链表，在链表中专门放那些可能存在循环引用的对象(能存放其他对象的对象)，如list,dict,tuple,set等。 在python内部某种情况下区扫描这个可能循环引用的链表，检查是否有循环引用，如果有就让双方的引用计数器都减1，如果计数器是0就垃圾回收。 因此，python就有了两个链表。 问题来了： 什么时候扫描？ 扫描的代价：每次不仅要扫描可能有循环引用的对象，还要扫描其子元素是否有循环引用 扫描的代价很大，每次全部扫描成本很高，频繁扫描严重消耗性能，所以引入了对象分代机制。 分代回收实现：将可能存在循环引用的对象维护成3个链表： 0代链表：规定0代中对象个数达到700个就扫描1次。 1代链表：规定0代扫描10次，1代扫描1次。 2代链表：规定1代扫描10次，2代扫描1次。 最开始可能有循环引用的对象都将添加到0代，直到达到了700个，就进行1次扫描，如果有循环引用就计数器都减1，回收垃圾，如果没有，接下来的对象就添加到1代链表,如果再满了，就加到2代链表。 缓存机制池为了避免重复去创建和销毁常见对象，将常见对象(int,str)放在了一个池里，也就是说池里的对象永远不会被回收。 1234567# python内部会创建从-5到257的值，放在池里，所以创建t1 = 3时，不会重新开辟内存，直接从池里拿# int的数据池也被称为小数据池small_intst1 = 3t2 = 6t3 = 3 #t3和t1指向的内存地址一模一样--id(t3) == id(t1)t4 = 300 # 会重新创建对象t5 = 300 # 也会重新创建对象,t5与t4内存地址不同--id(t4) != id(t5) 对于字符串str类型，内部将所有的ASCII字符缓存到了unicode_latin[256]链表中，以后不用再反复创建。 12345s1 = 'C'print(s1) #out:1343834377264del s1s2 = 'C'print(s2) #out:1343834377264 s1和s2用的是同一个id地址 字符串驻留机制：对于只有字符，数字，下划线且长度不大于20的字符串，会缓存到内存中，再次创建一模一样的字符串时，不会再次开辟内存，而是直接从内存中取出来。 12345s1 = 'abcde'print(id(s1)) #out:1996598711216del s1s2 = 'abcde'print(id(s2)) #out:1996598711216 free_list链表当一个对象(float,list,dict,tuple)的引用计数器为0时，按理说应该回收，但内部不直接回收，而是放到free_list链表中当作缓存，下次再创建相同类型的对象时就不用重新开辟内存了，而是直接使用free_list链表。 1234pie = 3.14 # 创建float类型对象，开辟内存，添加到refchain中del pie # 从refchain移除，添加到free_list中# 再次创建float类型t2 = 6.88 # 不会重新开辟内存，从free_list中获取对象，对象数据初始化再放到refchain中。 但是不是所以数据都缓存到free_list中，而是有数量限制，假设只能放100个对象，超过了100就会删除最先添加的对象。","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"判断异序字符串","slug":"判断异序字符串","date":"2020-07-29T04:00:31.367Z","updated":"2020-07-29T04:06:05.343Z","comments":true,"path":"2020/07/29/判断异序字符串/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/%E5%88%A4%E6%96%AD%E5%BC%82%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"需求判断两个单词是不是异序词，判断时忽略大小写，例如earth和heart就是异序词。以如下两个随便写的字符串为例，进行判断：12a = 'adceWq'b = 'aCedqw' 1.利用内置函数sorted：先判断长度，字母都变成小写，进行排序判断 – O(n^2^)123456def sort_word(a,b): if len(a) == len(b) and sorted(a.lower()) == sorted(b.lower()): return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b) else: return 'No...'print(sort_word(a,b)) 2.清点法：将a的每一个字母添加到一个列表,如果b某一个字母不在a里面那就是不同字母 –O(n^2^)12345678def justify(a,b): if len(a) == len(b): for i in b.lower(): if i not in list(a.lower()): return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)print(justify(a,b)) 3.蛮力法：将a生成所有的可能的字符串列表，看b是不是在里面—特别慢 O(n!)123456c = [[b1,b2,b3,b4,b5,b6] for b1 in a.lower() for b2 in a.lower().replace(b1,'') for b3 in a.lower().replace(b1,'').replace(b2,'') for b4 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'') for b5 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'') for b6 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'').replace(b5,'')]# print(c)if list(b.lower()) in c: print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)) 本来要将上面的方法简化一下，写成函数，函数恐怕也只能迭代了，迭代的速度也很低，没找到好方法，欢迎大家提供，这个方法其实是把问题变成了另一个问题：一个length为n的字符串随机排列的可能性，第一个字母有n中可能，第二个字母有n-1种可能性，所以一共就是1到n的累加种可能性：n*(n+1)/24.计数法：自己写一个或者利用collections的Counter模块123456789101112131415161718192021def count(a,b): # 先建立两个含有26个0的列表用来计数每个字母出现了几次 l1 = [0] * 26 l2 = [0] * 26 for i in range(len(a)-1): # a 对应数字97，以a为基准 pos = ord(a.lower()[i]) - ord('a') l1[pos] += 1 for i in range(len(b)-1): pos = ord(b.lower()[i]) - ord('a') l2[pos] += 1 # 判断生成的两个列表是否一样 for i in range(27): if l1[i] != l2[i]: return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a, b)from collections import Counterif Counter(a.lower()) == Counter(b.lower()): print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b))print(count(a,b))","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"glob文件操作","slug":"glob模块","date":"2020-07-28T08:02:57.792Z","updated":"2020-07-28T08:04:42.130Z","comments":true,"path":"2020/07/28/glob模块/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/glob%E6%A8%A1%E5%9D%97/","excerpt":"","text":"glob模块:查找文件和目录可使用的通配符： *匹配0或多个字符 ** 匹配所有文件,目录，子目录和子目录里面的文件 ？ 匹配一个字符,这里与正则表达式? (正则?匹配前面表达式0次或者1次) [] 匹配指定范围内的字符,如: [1-9]匹配1至9内的字符 [!] 匹配不在指定范围内的字符 查找当前路径下所有py文件：12for fname in glob.glob(\"**/*.py\",recursive=True): # recursive=True也查找子文件夹中的文件 print(fname) 当前路径文件tmp下py文件:12for fname in glob.glob(\"./tmp/*.py\"): print(fname) 当前路径文件下以file开头后有一个字符的py文件:12for fname in glob.glob(\"./file?.py\"): print(fname) 当前路径文件下以file开头后一个数字符的py文件:12for fname in glob.glob(\"./file[0-9].py\"): print(fname) 当前路径文件下以file开头后一个非数字符的py文件:12for fname in glob.glob(\"./file[!0-9].py\"): print(fname) 查询子目录：12for name in glob.glob('dir/*/*'): print ('\\t', name) glob模块iglob 返回iterator执行效率更高:当前路径文件tmp下py文件:12for fname in glob.iglob(\"./tmp/*.py\"): print(fname)","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"}]},{"title":"python statistics模块","slug":"python数学统计","date":"2020-07-28T06:11:27.486Z","updated":"2020-07-28T06:12:12.085Z","comments":true,"path":"2020/07/28/python数学统计/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/python%E6%95%B0%E5%AD%A6%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"统计模块statistics statistics.mean(data) ：平均值，可输入列表，含小数的decimal statistics.harmonic_mean(data): 调和平均数(倒数平均数) statistics.median(data)： 中值 median([1, 3, 5, 7]) =&gt; 4 statistics.median_low(data)：小中值 median_low([1, 3, 5, 7]) =&gt; 3 statistics.median_high(data)：大中值 median_low([1, 3, 5, 7]) =&gt; 5 statistics.median_grouped(data, interval=1)：用组距式来求中位数 statistics.mode(data): 众数 statistics.pstdev(data, mu=None): 总体标准差 statistics.pvariance(data, mu=None): 总体方差 statistics.stdev(data, xbar=None): 样本标准差 statistics.variance(data, xbar=None): 样本方差 总体方差的分母却是n。样本方差的分母是n-1。","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"javascript原型链","slug":"js原型链","date":"2020-07-28T06:06:51.928Z","updated":"2020-07-28T10:04:19.310Z","comments":true,"path":"2020/07/28/js原型链/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/js%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"javascript原型原型链：每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。概念： prototype:每一个函数都有这个属性，指向函数的原型对象； __proto__:每一个 new 出来的对象都有这个属性，指向这个对象的原型(prototype )； constructor:每一个原型都有一个constructor属性，指向关联的构造函数 关键：原型对象也是一个对象，也有自己的\\proto__属性，所以就形成了继承链。相关： 在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。 ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数： 123456var a = &#123;a: 1&#125;; // a ---&gt; Object.prototype ---&gt; null var b = Object.create(a);// b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.a); //b的原型对象就是a javascript是没有真正意义上的类的，所谓的类就是基于原型链和继承来实现的，即使ES6中加入了class,extends关键字实现类和继承，但实际上还是基于原型链和继承， ES6 类（class）是 JavaScript 现有的原型继承的语法糖。 实际上在定义一个对象的时候原型链本身就已经生成了，javascript处处皆对象的思想放在这里理解起来就很容易了，看完后你会发现万物始于Object.prototype。 ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 class, constructor, static, extends, 和 super. 语法糖就相当于汉语里的成语。即，用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率。","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"}]},{"title":"jQuery的引入","slug":"jQuery","date":"2020-07-28T06:01:33.445Z","updated":"2020-07-28T06:04:04.835Z","comments":true,"path":"2020/07/28/jQuery/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/jQuery/","excerpt":"","text":"jQuery 引入jQuery1234路径引入&lt;script src='文件路径'&gt;&lt;/script&gt;引入在线资源&lt;script src = \"https://code.jquery.com/jquery-1.12.4.js\"&gt;&lt;/script&gt; 入口函数123456$(document).ready(function()&#123; //类似于原生js的window.onload&#125;);//简写$(function()&#123; &#125;); 实例 12345678$(\"td\").hover( function () &#123; $(this).addClass(\"hover\"); &#125;, function () &#123; $(this).removeClass(\"hover\"); &#125;);","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"},{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"}]}