{"meta":{"title":"Gxzblog","subtitle":"python advance","description":"Life is short, I enjoy python.","author":"Gxzblog","url":"https://github.com/Gyz-polymer/Gyz-polymer.github.io","root":"/Gyz-polymer.github.io/"},"pages":[],"posts":[{"title":"水仙花数","slug":"水仙花数","date":"2020-08-27T02:54:47.515Z","updated":"2020-08-27T02:57:47.525Z","comments":true,"path":"2020/08/27/水仙花数/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/27/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/","excerpt":"","text":"水仙花数查找水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯特朗数（Armstrong number），水仙花数是指一个 n 位数，它的每个位上的数字的 n次幂之和等于它本身（例如三位数：153，370，四位数：1634，8208）等，接下来用python, javascript, c++分别实现查找所有水仙花数。 基本思想:根据输入的查找范围，如10000，将从1开始到10000累加循环，根据每个数的长度n求其所有位数n次幂的和，但是由于整数无法求长度，所以要将整数转化为字符串，然后再利用字符串切片求出每一位。python输入要查找的范围low to high 123456789def findNarcissistic(low,high): for i in range(low,high + 1): s = str(i) # 字符串是可迭代的，可切片的 result = sum([int(n) ** len(s) for n in s]) if result == i: print(i)findNarcissistic(0,10000000) 也可以默认从1开始查： 1234567def findNarcissistic(num): for i in range(num + 1): s = str(i) # 字符串是可迭代的，可切片的 result = sum([int(n) ** len(s) for n in s]) if result == i: print(i) JavaScript1234567891011121314function findNarcissistic(n) &#123; for (let i = 1; i &lt; n + 1; i++) &#123; let result = 0; // 将数字转化为字符串进行切片，求和 for(let m = 0; m &lt; i.toString().length; m++) &#123; result += Math.pow(+i.toString()[m],i.toString().length); &#125; if (result === i) &#123; console.log(i); &#125; &#125;&#125;findNarcissistic(99999); c++123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;// 查找水仙花数int main()&#123; int n; cout&lt;&lt;\"请输入要查找的上限：\"&lt;&lt;endl; cin&gt;&gt;n; for (int i = 1; i &lt; n + 1; i++) &#123; // 将输入的数字转化为字符串，进行获取长度和切片的操作 string str = to_string(i); double result = 0; for (int m = 0; m &lt; str.length(); m++) &#123; // pow()接收两个double参数 double each; // 将字符转换为数字，否则会识别为对应的ascii码，如1被识别为49 stringstream ss; ss&lt;&lt;str[m]; ss&gt;&gt;each; result += pow(each,str.length()); &#125; if (result == i) &#123; cout&lt;&lt;i&lt;&lt;endl; &#125; &#125;&#125; 性能：当查找到100万以上时，python慢一些，数量级越大python会慢的越多，js和c++速度很快，但是c++由于编译需要时间，查找到100万的速度还赶不上js，我的电脑js查找到100万也就2秒钟，当查找到1000万以上时c++速度还是比不上js，如下时用c++查询的1000万以内的水仙花数： 1234567891533703714071634820894745474892727930845488341741725421081898008179926315 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/JavaScript/"},{"name":"C++","slug":"C","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/C/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"C++","slug":"C","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/C/"},{"name":"水仙花数","slug":"水仙花数","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/"}]},{"title":"队列和双端队列 Queue and Deque","slug":"队列Queue-js","date":"2020-08-15T13:32:14.107Z","updated":"2020-08-15T13:33:07.018Z","comments":true,"path":"2020/08/15/队列Queue-js/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/15/%E9%98%9F%E5%88%97Queue-js/","excerpt":"","text":"队列和双端队列在前面的博客里已经介绍了python如何实现队列和双端队列，以及二者的简单应用，此处只介绍如何利用JavaScript的数组来实现队列。 为了便于理解，增加代码的简洁性，此处没有对数据进行抽象封装，如何对数组数据进行封装在上一篇博客（栈 Stack）中已经详细介绍了两种方法，此处就不赘述了。 队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Queue &#123; // 构造函数 constructor() &#123; this.count = 0; // 标记移除头部第一个元素的位置 this.lowerstCount = 0; this.items = &#123;&#125;; &#125;; // 判断是否为空 isEmpty() &#123; return this.count - this.lowerstCount === 0; &#125;; // 获取队列大小 size() &#123; return this.count - this.lowerstCount; &#125;; // 向队列尾部添加元素 enqueue(element) &#123; this.items[this.count] = element; this.count++; &#125;; // 移除队列头部元素 dequeue(element) &#123; if (this.isEmpty()) &#123; return undefined; &#125; const result = this.items[this.lowerstCount]; delete this.items[this.lowerstCount]; this.lowerstCount++; return result; &#125;; // 查看第一个元素 peek() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.lowerstCount]; &#125;; // 清空队列 clear() &#123; this.count = 0; this.lowerstCount = 0; this.items = &#123;&#125;; &#125;; // 定义打印队列 toString() &#123; if (this.isEmpty()) &#123; return ''; &#125; let result = `$&#123;this.items[this.lowerstCount]&#125;`; for (let i = this.lowerstCount + 1; i &lt; this.count; i++) &#123; result = `$&#123;result&#125;, $&#123;this.items[i]&#125;`; &#125; return result; &#125;;&#125;const queue = new Queue();console.log(queue.isEmpty()); //truequeue.enqueue(1);queue.enqueue(2);queue.enqueue(3);console.log(queue.isEmpty()); //falseconsole.log(queue.size()); //3console.log(queue.toString()); //1, 2, 3queue.dequeue();console.log(queue.toString()); //2, 3 双端队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Deque &#123; //构造函数 constructor() &#123; this.count = 0; this.lowerstCount = 0; this.items = &#123;&#125;; &#125;; // 判断是否为空 isEmpty() &#123; return this.count - this.lowerstCount === 0; &#125;; // 获取队列大小 size() &#123; return this.count - this.lowerstCount; &#125;; // 前端添加元素，也可使用数组unshift方法 addFront(element) &#123; if (this.isEmpty()) &#123; this.addBack(element); &#125; else if (this.lowerstCount &gt; 0) &#123; this.lowerstCount--; this.items[this.lowerstCount] = element; &#125; else &#123; // 所有元素全部后移1位 for (let i = this.count; i &gt; 0; i--) &#123; this.items[i] = this.items[i - 1]; &#125; this.count++; this.lowerstCount = 0; this.items[0] = element; &#125; &#125;; // 后端添加元素 addBack(element) &#123; this.items[this.count] = element; this.count++; &#125;; //前端删除元素,也可使用数组shift方法 removeFront() &#123; if (this.isEmpty()) &#123; return undefined; &#125; const result = this.items[this.lowerstCount]; delete this.items[this.lowerstCount]; this.lowerstCount++; return result; &#125;; // 后端删除元素 removeBack()&#123; //如果栈为空 if (this.isEmpty()) &#123; return undefined; &#125; this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; &#125;; // 清空队列 clear() &#123; this.count = 0; this.lowerstCount = 0; this.items = &#123;&#125;; &#125;; // 定义打印队列 toString() &#123; if (this.isEmpty()) &#123; return ''; &#125; let result = `$&#123;this.items[this.lowerstCount]&#125;`; for (let i = this.lowerstCount + 1; i &lt; this.count; i++) &#123; result = `$&#123;result&#125;, $&#123;this.items[i]&#125;`; &#125; return result; &#125;;&#125;const deque = new Deque();console.log(deque.isEmpty()); //trueconsole.log(deque.size()); //0deque.addBack(1);deque.addBack(2);deque.addBack(3);deque.addFront(0);console.log(deque.isEmpty()); //falseconsole.log(deque.size()); //0console.log(deque.toString()); //0, 1, 2, 3deque.removeBack();console.log(deque.toString()); //0, 1, 2deque.removeFront();console.log(deque.toString()); //1, 2 参考文献《学习JavaScript数据结构与算法(第3版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈 Stack","slug":"栈Stack-js","date":"2020-08-15T11:26:57.501Z","updated":"2020-08-15T11:58:13.403Z","comments":true,"path":"2020/08/15/栈Stack-js/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/15/%E6%A0%88Stack-js/","excerpt":"","text":"栈stackstack是一种数据结构，具有先进后出First In Last Out,后进先出的特点。只允许一头进出(添加操作)–顶端，(移除操作)–顶端，底端不发生变化。 就像在自助餐厅的一摞盘子，最上面的盘子是最后加上去的，但是总是最先被取走使用，这就是后进先出。 栈操作：❏ push(item)将一个元素添加到栈的顶端。它需要一个参数item，且无返回值。❏ pop()将栈顶端的元素移除。它不需要参数，但会返回顶端的元素，并且修改栈的内容。❏ peek()返回栈顶端的元素，但是并不移除该元素。它不需要参数，也不会修改栈的内容。❏ isEmpty()检查栈是否为空。它不需要参数，且会返回一个布尔值。❏ size()返回栈中元素的数目。它不需要参数，且会返回一个整数。JavaScript实现栈： 利用数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Stack &#123; // 构造函数 constructor() &#123; this.count = 0; this.items = &#123;&#125;; &#125;; // 获取栈的大小 size() &#123; return this.count; &#125;; // 判断栈是否为空 isEmpty() &#123; return this.count === 0; &#125;; // 压入：向栈添加元素 push(element) &#123; this.items[this.count] = element; this.count++; &#125;; // 弹出：从栈里删除元素 pop()&#123; //如果栈为空 if (this.isEmpty()) &#123; return undefined &#125; this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; &#125;; // 查看栈的顶端 peek() &#123; if (this.isEmpty()) &#123; return undefined &#125; return this.items[this.count - 1] &#125;; //清空栈:修改原始数据 clear() &#123; this.items = &#123;&#125;; this.count = 0; &#125;; // 第二种删除方法：逐个删除 clear2() &#123; while(! this.isEmpty()) &#123; this.items.pop(); &#125; &#125;; // 定义打印数组 toString() &#123; if (this.isEmpty()) &#123; return ''; &#125; let result = `$&#123;this.items[0]&#125;`; for (let i = 1; i &lt; this.count; i++) &#123; result = `$&#123;result&#125;, $&#123;this.items[i]&#125;`; &#125; return result; &#125;&#125;const stack = new Stack();console.log(stack.isEmpty());stack.push(5);stack.push(6);stack.push(4);console.log(stack);console.log(stack.isEmpty());stack.pop();console.log(stack);console.log(stack.toString()); 以上代码还有一个重要缺陷：数据封装的不完善。 123// 无法保证数据items私有化console.log(Object.getOwnPropertyNames(stack)); //可以任意获取[ 'count', 'items' ]console.log(stack.items); // 可以通过上一步继续获取数据 面对对象编程实现数据的封装，留下单独的API接口来开放需要公开的数据，而将原始数据抽象分离起来，保护数据安全。 为此可以采取以下办法把数组中的数据封装起来： 解决办法1：用Symbol实现类的数据私有封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const _items = Symbol('stackItems');const _count = Symbol('stackItems');class Stack2 &#123; constructor() &#123; this[_count] = 0; this[_items] = []; &#125;; size() &#123; return this[_count]; &#125;; isEmpty() &#123; return this[_count] === 0; &#125;; push(element) &#123; this[_items][this[_count]] = element; this[_count]++; &#125;; pop()&#123; //如果栈为空 if (this.isEmpty()) &#123; return undefined &#125; this[_count]--; const result = this[_items][this[_count]]; delete this[_items][this[_count]]; return result; &#125;; peek() &#123; if (this.isEmpty()) &#123; return undefined &#125; return this[_items][this[_count] - 1] &#125;; clear() &#123; this[_items] = []; this[_count] = 0; &#125;; clear2() &#123; while(! this.isEmpty()) &#123; this[_items].pop(); &#125; &#125;; toString() &#123; if (this.isEmpty()) &#123; return ''; &#125; let result = `$&#123;this[_items][0]&#125;`; for (let i = 1; i &lt; this[_count]; i++) &#123; result = `$&#123;result&#125;, $&#123;this[_items][i]&#125;`; &#125; return result; &#125;&#125;const stack2 = new Stack2();console.log(stack2.isEmpty());stack2.push(5);stack2.push(6);stack2.push(4);console.log(stack2);console.log(stack2.isEmpty());stack2.pop();console.log(stack2);console.log(stack2.toString());console.log(Object.getOwnPropertyNames(stack2)); // []console.log(stack2.items); // undefined 解决办法2：利用WeakMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const items = new WeakMap();const count = new WeakMap();class Stack3 &#123; constructor() &#123; count.set(this, 0); items.set(this, []); &#125; size() &#123; return count.get(this); &#125;; isEmpty() &#123; return count.get(this) === 0; &#125;; push(element) &#123; const s = items.get(this); s.push(element); let n = count.get(this); n++; count.set(this, n); &#125;; pop() &#123; if (this.isEmpty()) &#123; return undefined &#125; let n = count.get(this); n--; count.set(this, n); const s = items.get(this); const r = s.pop(); return r; &#125;; clear() &#123; count.set(this, 0); items.set(this, []); &#125;; toString() &#123; if (this.isEmpty()) &#123; return ''; &#125; return items.get(this); &#125;&#125;const stack3 = new Stack3();console.log(stack3.isEmpty());stack3.push(5);stack3.push(6);stack3.push(4);console.log(stack3); // Stack3 &#123;&#125;--完全’私有‘console.log(stack3.isEmpty());stack3.pop();console.log(stack3.toString()) //[ 5, 6 ]stack3.clear();console.log(stack3.isEmpty());console.log(stack3.toString()) // 为空console.log(Object.getOwnPropertyNames(stack3)) // [] 栈的应用： 还是举一下在python中构建栈的应用：转换进制 转进制为2-36进制 123456789101112131415161718192021222324function baseConverter(decNumber, base) &#123; const remStack = new Stack(); const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; let number = decNumber; let rem; let baseString = ''; if (! (base &gt;= 2 &amp;&amp; base &lt;= 36)) &#123; return ''; &#125; while (number &gt; 0) &#123; rem = Math.floor(number % base); remStack.push(rem); number = Math.floor(number / base); &#125; while (! remStack.isEmpty()) &#123; baseString += digits[remStack.pop()]; &#125; return baseString; &#125;console.log(baseConverter(16,2)) //10000 参考文献《学习JavaScript数据结构与算法(第3版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"环状双向链表 DoubleCycleLinkList","slug":"双向环状链表","date":"2020-08-10T01:47:41.945Z","updated":"2020-08-10T02:02:47.522Z","comments":true,"path":"2020/08/10/双向环状链表/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/10/%E5%8F%8C%E5%90%91%E7%8E%AF%E7%8A%B6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"环状双向链表在垃圾回收机制一文中讲过：环状双向链表：refchain—-python中创建的任意对象，都会加到refchain的双向链表中—包含了所有的python对象。 环状双向链表比之单向链表，多数操作方法的实现都没有什么不同，如is_empty, search, index等。这些方法都没有涉及节点的变动，也就可通过继承单向链表来实现即可。 不同之处一是在于节点实现的不同。增加了指向前一个节点的前驱区，因此需要为节点添加一个新属性pre，用以指向前一个节点。而且要实现环状必须让头节点的pre不再指向None，而是指向尾节点，同时让尾节点的next指向头节点。 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273# 创建节点node类，每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个和上一个节点的地址。class Node: def __init__(self, data): self.data = data # 将下一个节点初始值设为None self.next = None # 将上一个节点初始值设为None self.pre = None def getData(self): return self.data def getNext(self): return self.next def getPre(self): return self.pre def setData(self, newdata): self.data = newdata def setNext(self, newNext): self.next = newNext def setPre(self, newPre): self.pre = newPre# 构建环状双向链表类，获取第一个节点的引用class DoubleCycleLinkList: def __init__(self): # 列表初始化时并没有元素，所有引用也为空 self.head = None self.tail = None # 检查列表是否为空，只需要检查列表中头部的引用是否位None就可以，因为如果头部为空后面也是空 def isEmpty(self): # 布尔表达式self.head == None当且仅当链表中没有节点时才为真。 return self.head == None # 或 self.head is None # 获取链表长度 def length(self): if self.head: current = self.head # current是外部引用，被初始化为头节点 count = 1 while current != self.tail: count += 1 current = current.getNext() return count else: return 0 # 搜索链表 def search(self, item): current = self.head.getNext() # 将查询结构记录在found中 found = False # print(current.data) if self.head.data == item or self.tail.data == item: return True while current != self.tail and not found: if current.data == item: found = True else: current = current.getNext() return found # 遍历链表 def travel(self): current = self.head while current != self.tail: print(current.data, end='=&gt;') current = current.getNext() print(self.tail.data, end='=&gt;') # 增加一个换行 print() # 反向遍历链表 def reverse(self): if self.head and not self.tail: print(self.head.data, end='&lt;=') print() elif self.head and self.tail: current = self.tail while current != self.head: print(current.data, end='&lt;=') current = current.getPre() print(self.head.data, end='&lt;=') # 增加一个换行 print() else: return None # 搜索某个元素,返回位置，从0开始，如果没有返回None def index(self, item): current = self.head # 如果找到了元素 if self.search(item): count = 0 while current.data != item: count += 1 current = current.getNext() return count else: return None # 链表头部增加元素，元素的位置无所谓，重要的是方便和指引下一个元素 def add(self, item): # 创建一个新的结点 node = Node(item) if self.isEmpty(): self.head = node self.tail = node return # 获取原来的头节点 head = self.head # 原头节点的前驱区指向待插入节点 head.setPre(node) # 将新结点的下一个元素设置为原来的头节点 node.setNext(self.head) # 修改新节点为头节点 self.head = node self.head.setPre(self.tail) self.tail.setNext(node) # 向链表尾部添加元素 def append(self, item): # 创建一个新的结点 node = Node(item) current = self.head # 先判断是否为空链表 if self.isEmpty(): self.head = node self.tail = node return # 获取原来的尾节点 tail = self.tail # 原来的尾节点的下一个节点为node tail.setNext(node) # 设置node的上一个节点为原来的尾节点 node.setPre(tail) # 重新设置尾节点 self.tail = node node.setNext(self.head) self.head.setPre(node) # 向链表任意位置插入元素 def insert(self, pos, item): # 如果pos小于0，则在头部加入 if pos &lt;= 0: self.add(item) # 如果pos大于列表长度就在尾部添加 elif pos &gt; self.length()-1: self.append(item) # 在中间添加元素时 else: # 创建一个新节点 node = Node(item) current = self.head index = 0 while index &lt; pos - 1: current = current.getNext() index += 1 # 当index=pos-1时,获取下一个节点--即current为pos-1 next = current.getNext() # 新节点的前一个位置设为current节点 node.setPre(current) # 将新节点插入 current.setNext(node) # 设置node与后一个节点的关联 node.setNext(next) next.setPre(node) # 清空链表 def clear(self): self.head = None self.next = None # remove方法：先查找找到再删除，既要删除节点也要删除引用 def remove(self, item): # 如果找到了元素 if self.search(item): count = self.index(item) # 当是第一个元素时 if count == 0: # 获取原来的头节点 head = self.head next = head.getNext() # 设置新的头节点 self.head = next if self.length() != 1: self.tail.setNext(next) next.setPre(self.tail) # 当是最后一个元素时 elif count == self.length() -1: self.tail = self.tail.getPre() self.tail.setNext(self.head) self.head.setPre(self.tail) # 如果是中间元素 else: current = self.head next = current.getNext() pre = current.getPre() for i in range(self.length()): if i == count: next.setPre(pre) pre.setNext(next) current = current.getNext() # 删除一个元素 def pop(self,*pos): #如果链表非空 if self.head: current = self.head index = 0 # 参数*pos是一个元组，没有传入位置pos,删除最后一个 if not len(pos): # 获取原来的尾节点 tail = self.tail # 尾节点的前一个节点的下一个设为None pre = tail.getPre() pre.setNext(self.head) self.tail = pre self.head.setPre(self.tail) # 如果是删除第一个元素 elif pos[0] == 0: # 获取原来的头节点 head = self.head next = head.getNext() # 设置新的头节点 self.head = next if self.length() != 1: self.tail.setNext(next) next.setPre(self.tail) # 如果传入了位置pos else: # 获取元组第一个参数，也是唯一的参数 while 0 &lt; index &lt; pos[0] - 1: current = current.getNext() index += 1 # 当找到位置时(index=pos[0]-1),跳过当前元素,删除current的下一个元素 toBeRemoved = current.getNext() current.setNext(toBeRemoved.getNext()) toBeRemoved.getNext().setPre(current)ulist = DoubleCycleLinkList()print(ulist.isEmpty()) #out: Trueprint(ulist.length()) #out：0ulist.add('a')print(ulist.length()) #out: 1ulist.travel() #out: a=&gt;ulist.reverse() #out: a&lt;=print(ulist.isEmpty()) #out: Falseprint(ulist.search('a')) #out:Trueprint(ulist.index('a')) #out:0ulist.add('b')ulist.add('c')ulist.add('d')print(ulist.index('a')) #out:3print(ulist.search('d')) #out:Trueprint(ulist.length()) #out：4ulist.travel() #out: d=&gt;c=&gt;b=&gt;a=&gt;ulist.reverse() #out: a&lt;=b&lt;=c&lt;=d&lt;=print(ulist.search('a')) #out: Trueprint(ulist.index('b')) #out: 2ulist.remove('a')print(ulist.search('a')) #out: Falseulist.travel()ulist.append('w') #out: d=&gt;c=&gt;b=&gt;ulist.travel()ulist.insert(2,'v') #out: d=&gt;c=&gt;b=&gt;w=&gt;ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;w=&gt;ulist.pop()ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;ulist.pop()ulist.travel() #out: d=&gt;c=&gt;v=&gt;print(ulist.head.data) #out: dprint(ulist.tail.data) #out: vulist.pop(1)ulist.travel() #out:d=&gt;v=&gt;ulist.remove('v')ulist.travel() #out:d=&gt;ulist.clear()print(ulist.isEmpty()) #out: Trueprint(ulist.length()) #out: 0 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"双向链表 DoubleLinkList","slug":"双向链表","date":"2020-08-10T01:42:30.250Z","updated":"2020-08-10T02:02:47.515Z","comments":true,"path":"2020/08/10/双向链表/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/10/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"","text":"双向链表双向链表比之单向链表，多数操作方法的实现都没有什么不同，如is_empty, search, index等。这些方法都没有涉及节点的变动，也就可通过继承单向链表来实现即可。 不同之处一是在于节点实现的不同。因为增加了指向前一个节点的前驱区，因此需要为节点添加一个新属性pre，用以指向前一个节点。 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220# 创建节点node类，每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个和上一个节点的地址。class Node: def __init__(self, data): self.data = data # 将下一个节点初始值设为None self.next = None # 将上一个节点初始值设为None self.pre = None def getData(self): return self.data def getNext(self): return self.next def getPre(self): return self.pre def setData(self, newdata): self.data = newdata def setNext(self, newNext): self.next = newNext def setPre(self, newPre): self.pre = newPre# 构建双向链表类，获取第一个节点的引用class DoubleLinkList: def __init__(self): # 列表初始化时并没有元素，所有引用也为空 self.head = None self.tail = None # 检查列表是否为空，只需要检查列表中头部的引用是否位None就可以，因为如果头部为空后面也是空 def isEmpty(self): # 布尔表达式self.head == None当且仅当链表中没有节点时才为真。 return self.head == None # 或 self.head is None # 获取链表长度 def length(self): current = self.head # current是外部引用，被初始化为头节点 count = 0 while current != None: # None是最后一个节点的引用 count += 1 current = current.getNext() return count # 搜索链表 def search(self, item): current = self.head # 将查询结构记录在found中 found = False while current != None and not found: if current.getData() == item: found = True else: current = current.getNext() return found # 遍历链表 def travel(self): current = self.head while current != None: print(current.data, end='=&gt;') current = current.getNext() # 增加一个换行 print() # 搜索某个元素,返回位置，从0开始，如果没有返回None def index(self, item): current = self.head # 如果找到了元素 if self.search(item): count = 0 while current.getData() != item: count += 1 current = current.getNext() return count else: return None # 链表头部增加元素，元素的位置无所谓，重要的是方便和指引下一个元素 def add(self, item): # 创建一个新的结点 node = Node(item) if self.isEmpty(): self.head = node self.tail = node return # 获取原来的头节点 head = self.head # 原头节点的前驱区指向待插入节点 head.setPre(node) # 将新结点的下一个元素设置为原来的头节点 node.setNext(self.head) # 修改新节点为头节点 self.head = node # 向链表尾部添加元素 def append(self, item): # 创建一个新的结点 node = Node(item) current = self.head # 先判断是否为空链表 if self.isEmpty(): self.head = node self.tail = node return # 获取原来的尾节点 tail = self.tail # 原来的尾节点的下一个节点为node tail.setNext(node) # 设置node的上一个节点为原来的尾节点 node.setPre(tail) # 重新设置尾节点 self.tail = node # 向链表任意位置插入元素 def insert(self, pos, item): # 如果pos小于0，则在头部加入 if pos &lt;= 0: self.add(item) # 如果pos大于列表长度就在尾部添加 elif pos &gt; self.length()-1: self.append(item) # 在中间添加元素时 else: # 创建一个新节点 node = Node(item) current = self.head index = 0 while index &lt; pos - 1: current = current.getNext() index += 1 # 当index=pos-1时,获取下一个节点--即current为pos-1 next = current.getNext() # 新节点的前一个位置设为current节点 node.setPre(current) # 将新节点插入 current.setNext(node) # 设置node与后一个节点的关联 node.setNext(next) next.setPre(node) # 清空链表 def clear(self): self.head = None self.next = None # remove方法：先查找找到再删除，既要删除节点也要删除引用 def remove(self, item): # 如果找到了元素 if self.search(item): count = self.index(item) # 当是第一个元素时 if count == 0: self.head = self.head.getNext() if self.length() != 1: self.head.setPre(None) # 当是最后一个元素时 elif count == self.length() -1: self.tail = self.tail.getPre() self.tail.setNext(None) # 如果是中间元素 else: current = self.head next = current.getNext() pre = current.getPre() for i in range(self.length()): if i == count: next.setPre(pre) pre.setNext(next) current = current.getNext() # 删除一个元素 def pop(self,*pos): #如果链表非空 if self.head: current = self.head index = 0 # 参数*pos是一个元组，没有传入位置pos,删除最后一个 if not len(pos): # 获取原来的尾节点 tail = self.tail # 尾节点的前一个节点的下一个设为None pre = tail.getPre() pre.setNext(None) self.tail = pre # 如果传入了位置pos else: # 获取元组第一个参数，也是唯一的参数 while index &lt; pos[0] - 1: current = current.getNext() index += 1 # 当找到位置时(index=pos[0]-1),跳过当前元素,删除current的下一个元素 toBeRemoved = current.getNext() current.setNext(toBeRemoved.getNext()) toBeRemoved.getNext().setPre(current)ulist = DoubleLinkList()print(ulist.isEmpty()) #out: Trueulist.add('a')ulist.travel() #out: a=&gt;print(ulist.isEmpty()) #out: Falseulist.add('b')ulist.add('c')ulist.add('d')ulist.travel() #out: d=&gt;c=&gt;b=&gt;a=&gt;print(ulist.search('a')) #out: Trueprint(ulist.index('b')) #out: 2ulist.remove('a')print(ulist.search('a')) #out: Falseulist.travel() #out: d=&gt;c=&gt;b=&gt;ulist.append('w')ulist.travel() #out: d=&gt;c=&gt;b=&gt;w=&gt;ulist.insert(2,'v')ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;w=&gt;ulist.pop()ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;ulist.pop()ulist.travel() #out: d=&gt;c=&gt;v=&gt;print(ulist.head.data) #out: dprint(ulist.tail.data) #out: vulist.pop(1)ulist.travel() #out:d=&gt;v=&gt;ulist.remove('v')ulist.travel() #out:d=&gt;ulist.clear()print(ulist.isEmpty()) #out: Trueprint(ulist.length()) #out: 0 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树BinaryTree","slug":"二叉树BinaryTree","date":"2020-08-07T16:59:49.114Z","updated":"2020-08-07T17:06:17.620Z","comments":true,"path":"2020/08/08/二叉树BinaryTree/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/08/%E4%BA%8C%E5%8F%89%E6%A0%91BinaryTree/","excerpt":"","text":"二叉树BinaryTree树树状图是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 二叉树如果每个节点最多有两个子节点，我们就称这样的树为二叉树。二叉树是一种最简单且最重要的树。 完全二叉树：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。 一颗典型的’树’： 树的遍历将对所有节点的访问称为“遍历”，共有3种遍历二叉树的方式，分别为前序遍历、中序遍历和后序遍历。 前序遍历在前序遍历中，先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树。 中序遍历在中序遍历中，先递归地中序遍历左子树，然后访问根节点，最后递归地中序遍历右子树。 后序遍历在后序遍历中，先递归地后序遍历右子树，然后递归地后序遍历左子树，最后访问根节点。 二叉树的实现❏ BinaryTree()创建一个二叉树实例。❏ getLeftChild()返回当前节点的左子节点所对应的二叉树。❏ getRightChild()返回当前节点的右子节点所对应的二叉树。❏ setRootVal(val)在当前节点中存储参数val中的对象。❏ getRootVal()返回当前节点存储的对象。❏ insertLeft(val)新建一棵二叉树，并将其作为当前节点的左子节点。❏ insertRight(val)新建一棵二叉树，并将其作为当前节点的右子节点。实现树的关键在于选择一个好的内部存储技巧。 Python提供两种有意思的方式，第一种称作“列表之列表”，第二种称作“节点与引用”。 列表之列表利用列表层层嵌套列表来表示树的结构与父子节点层次123456789101112131415161718192021222324252627282930313233343536def BinaryTrees(r): return [r, [], []]def insertLeft(root, newBranch): # 让t为root的第二个元素，看t的长度 t = root.pop(1) if len(t) &gt; 1: root.insert(1, [newBranch, t, []]) else: root.insert(1, [newBranch, [], []]) return rootdef insertRight(root, newBranch): t = root.pop(2) if len(t) &gt; 1: root.insert(2, [newBranch, [], t]) else: root.insert(2, [newBranch, [], []]) return root# 设置根节点def setRootVal(root, newVal): root[0] = newVal# 获取根节点def getRootVal(root): return root[0]def getLeftChild(root): return root[1]def getRightChild(root): return root[2]br = BinaryTrees('a')insertLeft(br, 'b')insertLeft(br[1], 'd')insertRight(br[1],'e')insertRight(br,'c')insertRight(br[2],'f')# out: ['a', ['b', ['d', [], []], ['e', [], []]], ['c', [], ['f', [], []]]]print(br) 节点与引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class BinaryTree: def __init__(self, rootObj): self.key = rootObj self.leftChild = None self.rightChild = None # 插入左子节点 def insertLeft(self, newNode): # 没有子节点时直接插入 if self.leftChild == None: self.leftChild = BinaryTree(newNode) # 如果已经有了，就插入，将原来的节点降一层 else: t = BinaryTree(newNode) t.left = self.leftChild self.leftChild = t # 插入右子节点 def insertRight(self, newNode): if self.rightChild == None: self.rightChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.right = self.rightChild self.rightChild = t # 访问节点 def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild # 设置根节点 def setRootVal(self, key): self.key = key # 获取根节点 def getRootVal(self): return self.key # 前序遍历 def preTravel(self): # 打印根节点 print(self.key) # 遍历左子树 if self.leftChild: self.leftChild.preTravel() # 遍历右子树 if self.rightChild: self.rightChild.preTravel() # 中序遍历 def inTravel(self): # 遍历左子树 if self.leftChild: self.leftChild.inTravel() # 打印根节点 print(self.key) # 遍历右子树 if self.rightChild: self.rightChild.inTravel() # 后续遍历 def postTravel(self): # 遍历右子树 if self.rightChild: self.rightChild.postTravel() # 遍历左子树 if self.leftChild: self.leftChild.postTravel() # 打印根节点 print(self.key)br = BinaryTree('a')print(br.getRootVal()) #out: aprint(br.getLeftChild()) #out: Noneprint(br.getRightChild()) #out: Nonebr.insertLeft('b')br.insertRight('c')print(br.getLeftChild().getRootVal()) #out: bbr.leftChild.insertLeft('d')br.leftChild.insertRight('e')print(br.getLeftChild().getLeftChild().getRootVal()) #out: dprint(br.getLeftChild().getRightChild().getRootVal()) #out: ebr.rightChild.insertLeft('f')print(br.getRightChild().getLeftChild().getRootVal()) #out: fbr.preTravel() # 打印整个树--前序遍历br.inTravel() # 打印整个树--中序遍历br.postTravel() # 打印整个树--后序遍历 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"散列表hashTable","slug":"散列表hashTable","date":"2020-08-05T00:10:42.791Z","updated":"2020-08-10T01:38:16.744Z","comments":true,"path":"2020/08/05/散列表hashTable/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/05/%E6%95%A3%E5%88%97%E8%A1%A8hashTable/","excerpt":"","text":"散列表hashTable散列就是我们常说的哈希hash。散列表是元素集合，其中的元素以一种便于查找的方式存储。散列表中的每个位置通常被称为槽，其中可以存储一个元素。槽用一个从0开始的整数标记，例如0号槽、1号槽、2号槽，等等。初始情形下，散列表中没有元素，每个槽都是空的。可以用列表来实现散列表，并将每个元素都初始化为Python中的特殊值None。 散列函数将散列表中的元素与其所属位置对应起来。对散列表中的任一元素，散列函数返回一个介于0和m -1之间的整数。 常见的散列函数有“取余函数”，即用一个元素除以表的大小，并将得到的余数作为散列值（h(item) = item%size）。 槽的占用率被称作载荷因子，记作λ，定义如下: 散列函数会将两个元素都放入同一个槽，这种情况被称作冲突，也叫“碰撞”。当两个元素被分到同一个槽中时，必须通过一种系统化方法在散列表中安置第二个元素。这个过程被称为处理冲突。载荷因子越大，冲突的可能性越高。 再散列再散列泛指在发生冲突后寻找另一个槽的过程。简单的做法是从起初的散列值开始，顺序遍历散列表，直到找到一个空槽。 由于是逐个访问槽，因此这个做法被称作线性探测。 散列表得实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class hashTable(): def __init__(self): self._size = 10 # 列表slots存放key，列表data存放value self.slots = [None] * self._size self.value = [None] * self._size # 向散列表中添加元素 def put(self, key, value): # 获取元素槽的位置 hashvalue = self.hashfunction(key, len(self.slots)) # 如果槽是空的--就放入槽中值 if self.slots[hashvalue] == None: self.slots[hashvalue] = key self.value[hashvalue] = value # 如果槽是满的 else: # 如果满的槽对应现在的key，就执行替换操作 if self.slots[hashvalue] == key: self.value[hashvalue] = value # 如果槽是满的，说明key对应的值已经有了--冲突，进行再散列 else: # 获取下一个槽 nextslot = self.rehash(hashvalue, len(self.slots)) # 找出一个空槽 while self.slots[nextslot] != None and self.slots[nextslot] != key: nextslot = self.rehash(nextslot, len(self.slots)) # 如果槽是空的就添加 if self.slots[nextslot] == None: self.slots[nextslot] = key self.value[nextslot] = value # 否则替换 else: self.value[nextslot] = value # 散列函数：将散列表中的元素与所属位置对应起来--此处是将键整除长度取余数作为槽的位置 def hashfunction(self, key, size): return key % size # 处理冲突：再散列--解决散列函数的冲突--将键加1再整除长度取余数作为槽的位置 def rehash(self, oldhash, size): return (oldhash + 1) % size # 根据键获取值 def get(self, key): # 利用散列函数获取键的位置--没有冲突时的位置 startslot = self.hashfunction(key, len(self.slots)) data = None stop = False found = False position = startslot while self.slots[position] != None and not found and not stop: # 没有冲突时 if self.slots[position] == key: found = True data = self.value[position] # 冲突时--获取再散列的位置 else: position = self.rehash(position, len(self.slots)) if position == startslot: stop = True return data # 设置实现的魔法方法 def __getitem__(self, key): return self.get(key) def __setitem__(self, key, data): self.put(key, data)ha = hashTable()ha[19] = 'a'ha[26] = 'b'ha[33] = 'c'ha[67] = 'd'ha[54] = 'e'ha[94] = 'f'ha[74] = 'g'ha[14] = 'h'print(ha.slots)print(ha.value)print(ha[14]) #out: hha[14] = 'i'print(ha[14]) #out: i 应用散列表的应用太多，python的字典就是通过散列表实现的，实现的基本原理(简单原理)如上述代码，字典dict会根据需要实现动态开辟内存，扩展字典的长度，并保持一个比较合适的载荷因子(约70%)。 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"魔法方法","slug":"魔法方法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"}]},{"title":"数据集dataSet","slug":"数据集dataSet","date":"2020-08-03T07:11:16.234Z","updated":"2020-08-03T07:33:47.296Z","comments":true,"path":"2020/08/03/数据集dataSet/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/03/%E6%95%B0%E6%8D%AE%E9%9B%86dataSet/","excerpt":"","text":"数据集dataSet定义：为了计算需要的统计数据，如平均数，最大数，最小数，方差等，我们需要跟踪整组分数。在统计里，我们把这些分数称为数据集（dataset）。 功能： ❏ Dataset()创建一个空数据集。它不需要参数。❏ size()获取数据集的长度。它不需要参数。❏ add(item)给数据集添加一个数据。它需要一个参数：要添加的数据。❏ average()获取数据集的平均数。它不需要参数。❏ min()获取数据集的最小数。它不需要参数。❏ max()获取数据集的最大数。它不需要参数。❏ squares()获取数据集所有元素的平方和。它不需要参数。❏ sdev()获取数据集的统计方差。它不需要参数。怎样才能把数字输入到数据集（Dataset）里？最简单也最容易想到的就是利用列表或数组等保存数据，伪代码如下： 123456789101112131415161718192021222324class Dataset(object): \"\"\"Dataset is a collection of numbers from which simple descriptive statistics can be computed.\"\"\" def __init__(self): \"\"\"post: self is an empty Dataset\"\"\" def add(self, x): \"\"\"add x to the data set post: x is added to the data set\"\"\" def min(self): \"\"\"find the minimum pre: size of self &gt;= 1 post: returns smallest number in self\"\"\" def max(self): \"\"\"find the maximum pre: size of self &gt;= 1 post: returns largest number in self\"\"\" def average(self): \"\"\"calculate the mean pre: size of self &gt;= 1 post: returns the mean of the values in self\"\"\" def std_deviation(nums): \"\"\"calculate the standard deviation pre: size of self &gt;= 2 post: returns the standard deviation of the values in self\"\"\" 但是如上代码运行和逻辑上没有任何问题，但是在数据集超级大，含有千万上亿个元素时，造成的缓存就会很大，每次运行的时间也会随数据集长度的增加而线性增加，时间复杂度是O(n)。但是，所求的平均数，最大数等都不需要获取具体的数据，所以数据集可以只放结果和获取的接口而不存放具体的数据。 优化 封装：设计私有变量来存放统计数据的结果，设计单独的接口来获取私有变量 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from collections import dequeimport mathclass dataSet(object): def __init__(self): self._size = 0 self._average = None self._sum = 0 self._dmin = deque(maxlen=1) self._dmax = deque(maxlen=1) self._squares = 0 def add(self, item): self._size += 1 self._sum += item self._squares += item ** 2 self._average = self._sum / self._size if len(self._dmin) &lt; 1 or self._dmin[0] &gt; item: self._dmin.append(item) if len(self._dmax) &lt; 1 or self._dmax[0] &lt; item: self._dmax.append(item) def getSize(self): return self._size def getAverage(self): return self._average def getMin(self): return self._dmin[0] def getMax(self): return self._dmax[0] def getSquares(self): return self._squares def getSdev(self): return math.sqrt((self._squares - self._sum ** 2 / self._size) / (self._size - 1))newSet = dataSet()print(newSet.getSize()) #out: 0newSet.add(1)print(newSet.getSize()) #out: 1newSet.add(3)print(newSet.getSdev()) #out：1.4142135623730951print(newSet.getSquares()) #out：10print(newSet.getSize()) #out: 2newSet.add(5)newSet.add(6)newSet.add(9)print(newSet.getAverage()) #out：4.8print(newSet.getMin()) #out：1print(newSet.getMax()) #out：9 上面的代码引入了collections模块中的双端队列deque，用来限制缓存的长度，每次只保存一个元素。 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"有理数类","slug":"有理数类","date":"2020-08-03T05:41:11.270Z","updated":"2020-08-03T07:33:47.312Z","comments":true,"path":"2020/08/03/有理数类/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/08/03/%E6%9C%89%E7%90%86%E6%95%B0%E7%B1%BB/","excerpt":"","text":"有理数类在python中，含有小数的数字通常用float数据类型来表示。使用浮点数（float）的一个缺点是：底层存储方式只是一个近似值，而不是精确值。数字会首先被转换为二进制（基数2），因此不以2的幂作为分母的任何分数，都将会转换成具有无限循环的商。而当这个商数为了放进有限的存储器位置而被截断时，就会丢失一些精度。 解决办法：可以创建一个有理数类，专门存放小数来保存浮点数的完整性。 ❏ Rational(分子，分母)创建一个空列表。它接受两个参数，返回以字符串表示的分子，如1/2。❏ 实现Rational类实例对象之间的加减乘除操作，利用魔法函数实现。❏ 实现Rational类实例对象之间的大小比较，是否等于比较操作，利用魔法函数实现。❏ 实现分子分母约分，输出最简分数，利用欧几里得最大公约数算法实现。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Rational(object): # 构造函数：传入分子和分母 def __init__(self, num, den): ''' :param num: is interger :param den: is interger post: creates the Rational object num / den ''' self.num = num self.den = den # 分母不可以传入0 if den == 0: raise ValueError('分母不可以为0.') # 欧几里得算法求最大公约数：a 、b（a&gt;b）的最大公约数等于 b 和 a-b 的最大公约数。 def getGCD(self): x = self.num y = self.den while y: t = x % y x = y y = t return x # 在实例中使用加法 + def __add__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self + other ''' if self.den == other.den: num = self.num + other.num den = self.den else: num = self.num * other.den + self.den * other.num den = self.den * other.den return Rational(num, den) # 在实例中使用减法 - def __sub__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self + other ''' if self.den == other.den: num = self.num - other.num den = self.den else: num = self.num * other.den - self.den * other.num den = self.den * other.den return Rational(num, den) # 在实例中使用乘法 * def __mul__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self * other ''' num = self.num * other.num den = self.den * other.den return Rational(num, den) # 在实例中使用除法 / def __truediv__(self, other): ''' :param other: self and other are Rational bojects :return: Rational result:self * other ''' num = self.num * other.den den = self.den * other.num return Rational(num, den) # 在实例中使用取负 - def __neg__(self): ''' :param other: self is Rational bojects :return: Rational result:self * other ''' num = - self.num den = self.den return Rational(num, den) # 小于＜比较，返回布尔值 def __lt__(self, other): return (self.num / self.den - other.num / other.den) &lt; 0 # 小于等于＜=比较，返回布尔值 def __le__(self, other): return (self.num / self.den - other.num / other.den) &lt;= 0 # 大于大于比较，返回布尔值 def __gt__(self, other): return (self.num / self.den - other.num / other.den) &gt; 0 # 大于等于=＞比较，返回布尔值 def __ge__(self, other): return (self.num / self.den - other.num / other.den) &gt;= 0 # 等于==比较，返回布尔值 def __eq__(self, other): return (self.num / self.den - other.num / other.den) == 0 # 等于==比较，返回布尔值 def __ne__(self, other): return (self.num / self.den - other.num / other.den) != 0 # 定义print打印的返回值 def __str__(self): ''' self is a Rational object :return: return a string represent self ''' # 获得最大公约数 gcd = self.getGCD() # 返回值去点后面的.0 if str(self.num / gcd).split('.')[0] and str(self.den / gcd).split('.')[0]: return str(self.num / gcd).split('.')[0] + '/' + str(self.den / gcd).split('.')[0] else: return str(self.num / gcd) + '/' + str(self.den / gcd) 应用: 输出埃及分数古埃及人只用真分数，而且分数都表示成不同的单位分数(也就是分子为1，分母为各不相同的正整数)的和。如： 3/4 = 1/2 + 1/4 7/8 = 1/2 + 1/3 +1/24 算法原理：不解释分子为1和分子和分母`是倍数关系的简单情况，说一下一般情况。对于7/8，分解的第一个单位分数的分母是2，也就是：8 % 7 + 1，可以设置一个变量为 value = 分子 % 分母 + 1，然后判断二者之差7/8 - 1/value的分子是不是等于1，如果是就解决了，如果不是就进行迭代：现在的传入分数是7/8 - 1/value，直到结果的分子都等于1. 代码实现： 12345678910111213141516171819202122232425262728def getEgyptianFraction(r): i = True while (i): if r.num &gt;= r.den: raise ValueError('分子不能大于分母。') elif r.num == 1: print(\"1/&#123;&#125;\".format(r.den)) i = False break elif r.den % r.num == 0: print(\"1/&#123;&#125;\".format(int(r.den / r.num))) i = False break else: value = int(r.den / r.num) + 1 print(\"1/&#123;&#125;\".format(value), end=\"+\") # 迭代 newR = Rational(r.num * value - r.den, value * r.den) return getEgyptianFraction(newR)r0 = Rational(500 ,488)getEgyptianFraction(r1) #out: ValueError: 分子不能大于分母。r1 = Rational(7 ,8)getEgyptianFraction(r1) #out: 1/2+1/3+1/24r2 = Rational(475 ,488) getEgyptianFraction(r2) #out: 1/2+1/3+1/8+1/67+1/9809+1/481072596 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"魔法方法","slug":"魔法方法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"}]},{"title":"单向链表 SingleLinkList","slug":"单向链表SingleLinkList","date":"2020-07-31T10:30:28.509Z","updated":"2020-08-10T01:42:52.036Z","comments":true,"path":"2020/07/31/单向链表SingleLinkList/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/31/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8SingleLinkList/","excerpt":"","text":"单向链表链表是线性表的链式存储方式。逻辑上相邻的数据在计算机内的存储位置不一定相邻。链表的存储方式：通过节点Node储存数据。 每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个节点的地址，因此指针指向的类型也是节点类型。每个指针都指向下一个节点，都是朝一个方向的，这样的链表称为单向链表或单链表。 单链表的初始化是指构建一个空表。先创建一个头节点，不存储数据，然后令其指针域为空。 链表的一般特点：❏ SingleLinkList()创建一个空链表。它不需要参数，且会返回一个空列表。 ❏ add(item)向链表头部添加item。它接受一个元素作为参数，无返回值。 ❏ remove(item)从链表中移除item。它接受一个元素作为参数，并且修改列表。 ❏ search(item)在链表中搜索元素item。它接受一个元素作为参数，并且返回布尔值。 ❏ travel()打印整个链表，不需要参数。 ❏ isEmpty()检查列表是否为空。它不需要参数，并且返回布尔值。 ❏ length()返回列表中元素的个数。它不需要参数，并且返回一个整数。 ❏ append(item)在列表的尾部添加item。它接受一个元素作为参数，无返回值。 ❏ index(item)返回该元素在列表中的位置。它接受一个元素作为参数，并且返回该元素的下标(下标从0开始)。 ❏ insert(pos, item)假设元素item之前不在列表中，同时假设pos是合理的值，并在位置pos处添加元素item。它接受两个参数，无返回值。 ❏ pop()移除列表中的最后一个元素。它不需要参数，且会返回一个元素。 ❏ pop(pos)移除该位置上的元素。它接受位置参数，且会返回一个元素。 利用python实现单向链表创建链表节点Node类每个节点包含两个域：数据域和指针域。数据域存储数据元素，指针域存储下一个节点的地址。 12345678910111213class Node: def __init__(self, data): self.data = data # 将初始值设为None self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newdata): self.data = newdata def setNext(self, newNext): self.next = newNext 创建单向链表单向链表类本身并不包含任何节点对象，而只保存了指向列表头部的第一个节点的引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&gt;class SingleLinkList: def __init__(self): # 列表初始化时并没有元素，所有引用也为空 self.head =None # 检查列表是否为空，只需要检查列表中头部的引用是否位None就可以，因为如果头部为空后面也是空 def isEmpty(self): # 布尔表达式self.head == None当且仅当链表中没有节点时才为真。 return self.head == None # 获取链表长度 def length(self): current = self.head # current是外部引用，被初始化为头节点 count = 0 while current != None: # None是最后一个节点的引用 count += 1 current = current.getNext() return count # 搜索链表 def search(self, item): current = self.head # 将查询结构记录在found中 found = False while current != None and not found: if current.getData() == item: found = True else: current = current.getNext() return found # 遍历链表 def travel(self): current = self.head while current != None: print(current.value, end='=&gt;') current = current.getNext() # 增加一个换行 print() # 搜索某个元素,返回位置，从0开始，如果没有返回None def index(self, item): current = self.head # 如果找到了元素 if self.search(item): count = 0 while current.getData() != item: count += 1 current = current.getNext() return count # 链表头部增加元素，元素的位置无所谓，重要的是方便和指引下一个元素 def add(self, item): # 创建一个新的结点 node = Node(item) # 将新结点的下一个元素设置为头节点 node.setNext(self.head) # 修改新节点为头节点 self.head = node # 向链表尾部添加元素 def append(self, item): # 创建一个新的结点 node = Node(item) # 先判断是否为空链表 if self.isEmpty(): self.head = node # 若链表不为空 else: current = self.head # 遍历到倒数第二个节点的引用 while current.getNext() != None: current = current.getNext() # 当current时最后一个元素时,把新节点放在其后面 current.setNext(node) # 向链表任意位置插入元素 def insert(self, pos, item): # 如果pos小于0，则在头部加入 if pos &lt; 0: self.add(item) # 如果pos大于列表长度就在尾部添加 elif pos &gt; self.length()-1: self.append(item) # 在中间添加元素时 else: # 创建一个新节点 node = Node(item) current = self.head index = 0 while index &lt; pos - 1: current = current.getNext() index += 1 # 当index=pos-1时,获取下一个节点 next = current.getNext() # 将新节点插入 current.setNext(node) # 新节点的下一个位置设为next节点 node.setNext(next) # remove方法：先查找找到再删除，既要删除节点也要删除引用 def remove(self, item): current = self.head # previous指向上一次访问的节点 previous = None found = False # 先找到元素 while not found: if current.getData() == item: found = True else: previous = current current = current.getNext() # 当current是第一个元素时 if previous == None: self.head = current.getNext() # 最后一个元素也适用，下一个就是None else: previous.setNext(current.getNext()) # 删除最后一个元素 def pop(self,*pos): #如果链表非空 if self.head: current = self.head index = 0 # 参数*pos是一个元组，没有传入位置pos if not len(pos): # 找到倒数第二个元素的引用 while current.getNext().getNext() != None: current = current.getNext() # 设置最后一个元素为None current.setNext(None) # 如果传入了位置pos else: # 获取元组第一个参数，也是唯一的参数 while index &lt; pos[0] - 1: current = current.getNext() index += 1 # 当找到位置时,跳过当前元素 current.setNext(current.getNext().getNext())&gt;ulist = SingleLinkList()&gt;print(ulist.isEmpty()) #out: True&gt;ulist.add('a') #out: False&gt;ulist.travel() #out: a=&gt;&gt;print(ulist.isEmpty()) #out: False&gt;ulist.add('b')&gt;ulist.add('c')&gt;ulist.add('d')&gt;ulist.travel() #out: d=&gt;c=&gt;b=&gt;a=&gt;&gt;print(ulist.search('a')) #out: True&gt;print(ulist.index('b')) #out: 2&gt;ulist.remove('a')&gt;print(ulist.search('a')) #out: False&gt;ulist.travel()&gt;ulist.append('w') #out: d=&gt;c=&gt;b=&gt;&gt;ulist.travel()&gt;ulist.insert(2,'v') #out: d=&gt;c=&gt;b=&gt;w=&gt;&gt;ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;w=&gt;&gt;ulist.pop()&gt;ulist.travel() #out: d=&gt;c=&gt;v=&gt;b=&gt;&gt;ulist.pop()&gt;ulist.travel() #out: d=&gt;c=&gt;v=&gt;&gt;ulist.pop(1)&gt;ulist.travel() #out:d=&gt;v=&gt; 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"双端队列 Deque","slug":"双端队列Deque","date":"2020-07-30T05:01:55.864Z","updated":"2020-08-10T01:35:57.025Z","comments":true,"path":"2020/07/30/双端队列Deque/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/30/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97Deque/","excerpt":"","text":"双端队列deque双端队列是与队列类似的有序集合。它有一前、一后两端，元素在其中保持自己的位置。 与队列不同的是，双端队列对在哪一端添加和移除元素没有任何限制。新元素既可以被添加到前端，也可以被添加到后端。同理，已有的元素也能从任意一端移除。 某种意义上，双端队列是栈和队列的结合。 注意，不要把它的英文名deque（与deck同音）和队列的移除操作dequeue搞混了。 python实现双端队列的两种方式： 1.自定义双端队列12345678910111213141516# 假设双端队列的尾部是列表的头部[0]class Deque: def __init__(self): self.items = [] def addFront(self, item): self.items.insert(0,item) def addRear(self, item): self.items.append(item) def removeFront(self): return self.items.pop() def removeRear(self): return self.items.pop(0) def isEmpty(self): return self.items == [] def size(self): return len(self.items) 2. 也可以从collections模块中引入123456789101112131415161718192021from collections import dequed = deque()# 增加数据d.append('1')d.append('2')d.append('3')print(len(d),d[0],d[-1])f = deque(range(5))print(len(f))#两端删除数据print(f.popleft()) # 删除左端第一个数据print(f.pop()) # 删除右端第一个数据f.extend([6]) # 右端可增加数据,必须是可迭代数据，如列表，元组，集合setf.extendleft((8,)) # 左端增加数据f.extendleft(&#123;9&#125;) # 左端增加数据print(f)# 设定队列长度e = deque([0, 1, 2, 3, 5], maxlen=5)e.extend([2,3])print(e) # 输出：deque([2, 3, 5, 2, 3], maxlen=5) 应用：回文检测回文就是正向和反向读都一样的句子或单词：radar，假似真时真似假 人欺我处我欺人。 可以利用双端队列的双重性，其前端是字符串的第一个字符，后端是字符串的最后一个字符。123456789101112131415161718#回文检测def checker(string): check = Deque() # 将字符串中每一个字符添加到双端队列 for each in string: check.addRear(each) # 加一个flag，判断是否继续进行首尾对比 stillEqual = True # 区分字符串奇偶：长度 为0或1就停止比较 while check.size() &gt; 1 and stillEqual: first = check.removeFront() last = check.removeRear() if first != last: stillEqual = False return stillEqualprint(checker('lool')) # Trueprint(checker('look')) # False 也可以利用双端队列的特点生成回文：12345678910111213141516171819# 生成回文---可传入中文或英文单词def genPalindrome(string): pad = Deque() # 反转一下字符串 for each in reversed(string): pad.addRear(each) # 最后一个字符不能加两次 for each in reversed(string[:-1]): pad.addFront(each) # 创建一个列表用于保存结构 result = [] for i in range(pad.size()): each = pad.removeFront() result += each result = ''.join(result) return resultprint(genPalindrome('我很开心')) # out: 我很开心开很我print(genPalindrome('hello')) # out: hellolleh 扩展 pythoncollections 模块中的 deque可以实现获取指定长度的双端队列，这个功能时如何实现的呢？ 其实很简单，就是在构造函数中加入一个有默认值的长度参数：maxlen，如果不传入参数队列默认为无限长，如果传入正整数则为队列的长度，如果继续添加数据超过了队列长度，就会将在队列另一端的数据移除，并具有参数类型和大小判断功能：长度只能传入正整数。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import numbersclass Deque: def __init__(self, maxlen = None): self.items = [] self.maxlen = maxlen if maxlen is not None: if not isinstance(maxlen, numbers.Integral): raise TypeError(\"maxlen must be int\") elif maxlen &lt;= 0: raise ValueError(\"maxlen must be positive int\") def addFront(self, item): if not self.maxlen: self.items.insert(0,item) else: if len(self.items) &lt; self.maxlen: self.items.insert(0, item) else: self.items.pop() self.items.insert(0,item) def addRear(self, item): if not self.maxlen: self.items.append(item) else: if len(self.items) &lt; self.maxlen: self.items.append(item) else: self.items.pop(0) self.items.append(item) def removeFront(self): return self.items.pop() def removeRear(self): return self.items.pop(0) def isEmpty(self): return self.items == [] def size(self): if self.maxlen: return int(self.maxlen) else: return len(self.items) # 让实例化对象直接可以打印 def __str__(self): return str(self.items)d = Deque(maxlen = 3)d.addFront(1)print(d.items) ##out:[1]d.addFront(2)print(d.items) #out:[2, 1]d.addFront(3)print(d.items) #out:[3, 2, 1]d.addFront(4)print(d.items) #out:[ 4, 3, 2]d.addFront(5)print(d.items) #out:[5, 4, 3]d.addFront(6)print(d.items) #out:[6, 5, 4]d.addRear(7)print(d.items) #out:[5, 4, 7]print(d) # 可以直接打印出结果,因为定义了魔法函数__str__(self) 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"队列 Queue","slug":"队列Queue","date":"2020-07-30T03:01:20.803Z","updated":"2020-08-10T01:34:15.157Z","comments":true,"path":"2020/07/30/队列Queue/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/30/%E9%98%9F%E5%88%97Queue/","excerpt":"","text":"队列dequedeque是一种线性数据结构，具有先进先出First In First Out,后进后出的特点。只允许一头进(添加操作)–顶端，另一头出(移除操作)–底端。 队列：生活中排队买东西，先来的先买，后到的后买 用python实现队列： 用列表实现队列，队列的尾部在列表头部，队列头部在列表尾部 12345678910111213141516class Queue: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.insert(0,item) def dequeue(self): return self.items.pop() def size(self): return len(self.items) q = Queue()print(q.isEmpty()) # Trueq.enqueue('bobby')print(q.isEmpty()) # False 用列表实现队列，队列的头部在列表头部，队列尾部在列表尾部 1234567891011class QueueLeft: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def size(self): return len(self.items) 应用：约瑟夫问题一个游戏：每隔几个人移除一个人，如每数到7去掉一人 1234567891011121314def CountNum(nameArr,num): qu = Queue() for name in nameArr: # 在队列中名字顺序反过来了，刚好因为出栈顺序是先进先出 qu.enqueue(name) # 如果队列中人数多余一人，继续移除 while qu.size() &gt; 1: for i in range(num): # 移除队列的人马上从另一端重新加入队列 qu.enqueue(qu.dequeue()) # 每个num个人移除一个 qu.dequeue() return qu.dequeue()print(CountNum(['a','b','v','d','f','h','w','k','l','o','q'],7)) #out:l 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈 Stack","slug":"栈Stack","date":"2020-07-29T14:05:11.206Z","updated":"2020-08-10T01:42:30.248Z","comments":true,"path":"2020/07/29/栈Stack/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/%E6%A0%88Stack/","excerpt":"","text":"栈stackstack是一种数据结构，具有先进后出First In Last Out,后进先出的特点。只允许一头进出(添加操作)–顶端，(移除操作)–顶端，底端不发生变化。 就像在自助餐厅的一摞盘子，最上面的盘子是最后加上去的，但是总是最先被取走使用，这就是后进先出。 栈操作：❏ push(item)将一个元素添加到栈的顶端。它需要一个参数item，且无返回值。❏ pop()将栈顶端的元素移除。它不需要参数，但会返回顶端的元素，并且修改栈的内容。❏ peek()返回栈顶端的元素，但是并不移除该元素。它不需要参数，也不会修改栈的内容。❏ isEmpty()检查栈是否为空。它不需要参数，且会返回一个布尔值。❏ size()返回栈中元素的数目。它不需要参数，且会返回一个整数。利用python实现栈： 利用列表，假设列表的尾部是栈的头部 1234567891011121314151617181920212223242526272829# 实现栈Last In first Out的功能：push，pop,peek,isEmpty,size()# 用列表实现，假设列表的尾部是栈的顶端class Stack: def __init__(self): self.items = [] # 判断栈是不是空的 def isEmpty(self): return self.items == [] # 将元素添加到栈的顶端 def push(self,item): self.items.append(item) # 时间复杂度O(1) # 将元素从栈的顶端移除 def pop(self): return self.items.pop() # 时间复杂度O(1) # 返回栈顶端的数据 def peek(self): return self.items[len(self.items)-1] # 返回栈的大小 def size(self): return len(self.items)s1 = Stack()print(s1.isEmpty())s1.push(1)print(s1.isEmpty())s1.push(2)print(s1.peek())print(s1.size())print(s1.items) 利用列表，假设列表的头部是栈的头部 123456789101112131415161718class StackRight: def __init__(self): self.items = [] # 判断栈是不是空的 def isEmpty(self): return self.items == [] # 将元素添加到栈的顶端 def push(self,item): self.items.insert(0,item) # 时间复杂度O(n) # 将元素从栈的顶端移除 def pop(self): return self.items.pop(0) # 时间复杂度O(n) # 返回栈顶端的数据 def peek(self): return self.items[0] # 返回栈的大小 def size(self): return len(self.items) 应用：栈先进后出的特点有很多巧妙的应用 1.判断符号的匹配，python种表示[]列表，()表示元组，{}表示字典或集合，这些符号都是可以复用的，组合使用，如{[()()&lt;&gt;()]}是一个符合匹配的形式，而([)]，{([}不不符合匹配。利用栈可以判断是否符合匹配 1234567891011121314151617181920212223242526272829# 利用上面列表的尾部是栈的顶端---第一种方法实现栈def parChecker(pars): s = Stack() balanced = True index = 0 while index &lt; len(pars) and balanced: par = pars[index] if par in '&lt;(&#123;[': s.push(par) # 如果不是开始符号 else: if s.isEmpty(): # 说明closed的符号多了 balanced = False else: top = s.pop() # 获得弹出的符号 if not matches(top, par): # 判断弹出符号与当前的是否匹配 balanced = False index += 1 if balanced and s.isEmpty(): return True else: return Falsedef matches(start,close): # 判断是否匹配 starts = '&lt;(&#123;[' closes = '&gt;)&#125;]' # index获取字符在字符串中的位置 return starts.index(start) == closes.index(close)print(parChecker('&#123;[()()&lt;&gt;()]&#125;')) # out:Trueprint(parChecker('&#123;[()(&lt;&gt;()]&#125;')) # out:False 2.进制转换：十进制转换为二进制，一般转化成二进制是通过除以2的方法实现。 ​ 算法实现： 1234567891011121314# 利用上面列表的尾部是栈的顶端---第一种方法实现栈def divideBy2(decNumber): # c参数是十进制数字 remStack = Stack() while decNumber &gt; 0: rem = decNumber % 2 # 取余数并推入到栈里 remStack.push(rem) decNumber = decNumber // 2 binString = '' while not remStack.isEmpty(): binString = binString + str(remStack.pop()) # 从栈中弹出一位数添加到字符串中 return binStringprint(divideBy2(16)) #out:10000print(divideBy2(17)) #out:10001 ​ 进一步：实现多种进制的转换 1234567891011121314def divideByBase(decNumber,base): # base为要转化为的进制 # 创建一套可以表示16进制的字符 digits = '0123456789ABCDEF' remStack = Stack() while decNumber &gt; 0: rem = decNumber % base # 取余数作为最后一位 remStack.push(rem) decNumber = decNumber // base baseString = '' while not remStack.isEmpty(): baseString = baseString + str(remStack.pop()) return baseStringprint(divideByBase(16,16)) #转化为16进制，10print(divideByBase(32,8)) # 转化为8进制，40 3.中序，前序，后续表达式转换 对于A+B×C+D人类可以根据运算符优先级进行步骤计算：先算括号，再算乘除，最后加减。但是计算机并不认识加减乘除，必须加上括号才能识别优先级，前面的优先级就要写成：(A+(B×C)+D)，平白多了两对括号，为了解决这个问题就引入了前序和后续表达式，如下所示： 中序表达式 前序表达式 后序表达式 A + B + A B A B + A + B × C + A * B C A B C * + 若要将任意复杂的中序表达式转换成前序表达式或后序表达式，可以先将其写作完全括号表达式，然后将括号内的运算符移到左括号处（前序表达式）或者右括号处（后序表达式）。 只有中序表达式需要额外的符号来消除歧义。前序表达式和后序表达式的运算顺序完全由运算符的位置决定。鉴于此，中序表达式是最不理想的算式表达法。 算法实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 将中序表达式转化为后序表达式import stringdef infixToPostfix(infixexpr): # infixexpr：输入的表达式字符之间一定要有空格 prec = &#123;&#125; # 用数字表示运算符的优先级 prec['*'] = 3 prec['/'] = 3 prec['+'] = 2 prec['-'] = 2 prec['('] = 1 # 用于保存输入表达式中的所有运算符 newStack = Stack() # 列表保存结果：生成后续表达式 postFixList = [] # 将输入的表达式通过空格转换成列表 tokenList = infixexpr.split() #检查输入的表达式是否符合每个字符间有空格 for token in tokenList: if len(token) != 1: return '输入的表达式字符之间缺少空格...' # 对生成的列表逐个扫描 for token in tokenList: # 用所有大写字母表示表达式中所有可以出现的操作数 if token in string.ascii_uppercase: # 如果是操作数(A,B,C...)就加到列表末尾 postFixList.append(token) # 如果是左括号就压入栈 elif token == '(': newStack.push(token) # 如果是右括号就弹出栈，直到找到与之对应的左括号 elif token == ')': topToken = newStack.pop() while topToken != '(': # 把从栈中取出来的运算符都添加到列表末尾 postFixList.append(topToken) topToken = newStack.pop() # 如果是其他运算符 * / + - 就把运算符压入栈 else: # 压入之前，先判断：如果栈中的运算符优先于输入的运算符，就把栈中的运算符添加到列表末尾 while (not newStack.isEmpty()) and (prec[newStack.peek()] &gt;= prec[token]): postFixList.append(newStack.pop()) newStack.push(token) # 处理完所有输入后，将栈中残留的运算符全部添加到列表末尾 while not newStack.isEmpty(): postFixList.append(newStack.pop()) # 把列表变成字符串 return ' '.join(postFixList)print(infixToPostfix('A + B * C')) #out: A B C * +# 在A与+之间删除空格print(infixToPostfix('A+ B * C')) #out: 输入的表达式字符之间缺少空格... 参考文献《python数据结构与算法分析(第2版)》 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"垃圾回收和缓存机制","slug":"python垃圾回收和缓存机制","date":"2020-07-29T08:42:04.290Z","updated":"2020-08-03T05:24:51.798Z","comments":true,"path":"2020/07/29/python垃圾回收和缓存机制/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收机制一句话python垃圾回收：以引用计数为主，标记清除和分代回收为辅。引用计数器环状双向链表：refchain—-python中创建的任意对象，都会加到refchain的双向链表中—包含了所有的python对象 针对代码name = &#39;bobby&#39;, 底层c语言会创建如下4个数据： 上一个对象的指针 *_ob_prev和下一个对象的指针 *_ob_next(_Py_HEAD_EXTRA)—双向查找 数据的类型 ob_refcnt：如int,str,float等 引用计数 *ob_type。此时引用计数是1，如果再让new = name,则引用计数变为2。 每一个对象都有至少这四个值,这四个值存放在结构体PyObject 里。 由多个元素组成的对象，如字典，列表，集合等还有一个值ob_size，用来存储数据大小(元素的个数)。 除PyObject之外，Python中另一个重要的是PyVarObject了，它是变长对象，例如List、String，显然PyObject无法满足它们需求，所以就需要用到PyVarObject了，实际上，PyVarObject与PyObject相比只多了一个属性ob_size，它指明了变成对象中有多少个元素（不是字节数） c++中两个重要的结构体：PyObject 和PyVarObject就是上述这个作用。 举例：创建一个float的内部实现 12345678data = 3.14# 内部会创建_ob_next = refchain的下一个对象_ob_prev = refchain的上一个对象ob_refcnt = 1 # 默认是1，当有其他变量引用时，引用计数发送变化 del则减一，当引用为0时则进行对象回收ob_type = floatob_fval = 3.14# 回收：将对象从refchain中移除，将对象进行销毁，归还对象所占用的内存 python会根据数据类型的不同，找到其对应的结构体，根据结构体中的字段来创建相关的数据，然后将对象添加到refchain双向链表中。当引用为0时就当成垃圾删除 引用计数器的bug：循环引用12345678t1 = [1,2,3] #refchain创建一个列表，列表的引用计数为1t2 = [4,5,6] #refchain再创建一个列表，列表的引用计数为1t1.append(t2) # t2被追加到t1，则t2对应的对象[4,5,6]的引用计数器加1，变为2t2.append(t1) # t1被追加到t2，则v1对应的对象[1,2,3]的引用计数器加1，变为2del t1 # 引用计数器-1，还是1，无法回收del t2 # 引用计数器-1，还是1，无法回收# 但是，此时没有变量指向[1,2,3]和[4,5,6]这两个列表了，变成一直存在于内存中的垃圾 标记清除目的：解决循环引用实现：再python底层再维护一个链表，在链表中专门放那些可能存在循环引用的对象(能存放其他对象的对象)，如list,dict,tuple,set等。 在python内部某种情况下去扫描这个可能循环引用的链表，检查是否有循环引用，如果有就让双方的引用计数器都减1，如果计数器是0就垃圾回收。 因此，python就有了两个链表。 问题来了： 什么时候扫描？ 扫描的代价：每次不仅要扫描可能有循环引用的对象，还要扫描其子元素是否有循环引用！ 扫描的代价很大，每次全部扫描成本很高，频繁扫描严重消耗性能，所以引入了对象分代机制。 分代回收实现：将可能存在循环引用的对象维护成3个链表： 0代链表：规定0代中对象个数达到700个就扫描1次。 1代链表：规定0代扫描10次，1代扫描1次。 2代链表：规定1代扫描10次，2代扫描1次。 最开始可能有循环引用的对象都将添加到0代，直到达到了700个，就进行1次扫描，如果有循环引用就计数器都减1，回收垃圾，如果没有，接下来的对象就添加到1代链表,如果再满了，就加到2代链表。 缓存机制池为了避免重复去创建和销毁常见对象，将常见对象(int,str)放在了一个池里，也就是说池里的对象永远不会被回收。 1234567# python内部会创建从-5到257的值，放在池里，所以创建t1 = 3时，不会重新开辟内存，直接从池里拿# int的数据池也被称为小数据池small_intst1 = 3t2 = 6t3 = 3 #t3和t1指向的内存地址一模一样--id(t3) == id(t1)t4 = 300 # 会重新创建对象t5 = 300 # 也会重新创建对象,t5与t4内存地址不同--id(t4) != id(t5) 对于字符串str类型，内部将所有的ASCII字符缓存到了unicode_latin[256]链表中，以后不用再反复创建。 12345s1 = 'C'print(s1) #out:1343834377264del s1s2 = 'C'print(s2) #out:1343834377264 s1和s2用的是同一个id地址 字符串驻留机制：对于只有字符，数字，下划线且长度不大于20的字符串，会缓存到内存中，再次创建一模一样的字符串时，不会再次开辟内存，而是直接从内存中取出来。 12345s1 = 'abcde'print(id(s1)) #out:1996598711216del s1s2 = 'abcde'print(id(s2)) #out:1996598711216 free_list链表当一个对象(float,list,dict,tuple)的引用计数器为0时，按理说应该回收，但内部不直接回收，而是放到free_list链表中当作缓存，下次再创建相同类型的对象时就不用重新开辟内存了，而是直接使用free_list链表。 1234pie = 3.14 # 创建float类型对象，开辟内存，添加到refchain中del pie # 从refchain移除，添加到free_list中# 再次创建float类型t2 = 6.88 # 不会重新开辟内存，从free_list中获取对象，对象数据初始化再放到refchain中。 但不是所以数据都缓存到free_list中，而是有数量限制，假设只能放100个对象，超过了100就会删除最先添加的对象。 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"判断异序字符串","slug":"判断异序字符串","date":"2020-07-29T04:00:31.367Z","updated":"2020-08-03T05:24:51.767Z","comments":true,"path":"2020/07/29/判断异序字符串/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/%E5%88%A4%E6%96%AD%E5%BC%82%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"需求判断两个单词是不是异序词，判断时忽略大小写，例如earth和heart就是异序词。以如下两个随便写的字符串为例，进行判断：12a = 'adceWq'b = 'aCedqw' 1.利用内置函数sorted：先判断长度，字母都变成小写，进行排序判断 – O(n^2)123456def sort_word(a,b): if len(a) == len(b) and sorted(a.lower()) == sorted(b.lower()): return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b) else: return 'No...'print(sort_word(a,b)) 2.清点法：将a的每一个字母添加到一个列表,如果b某一个字母不在a里面那就是不同字母 –O(n^2)12345678def justify(a,b): if len(a) == len(b): for i in b.lower(): if i not in list(a.lower()): return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)print(justify(a,b)) 3.蛮力法：将a生成所有的可能的字符串列表，看b是不是在里面—特别慢 O(n!)123456c = [[b1,b2,b3,b4,b5,b6] for b1 in a.lower() for b2 in a.lower().replace(b1,'') for b3 in a.lower().replace(b1,'').replace(b2,'') for b4 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'') for b5 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'') for b6 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'').replace(b5,'')]# print(c)if list(b.lower()) in c: print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)) 本来要将上面的方法简化一下，写成函数，函数恐怕也只能迭代了，迭代的速度也很低，没找到好方法，欢迎大家提供，这个方法其实是把问题变成了另一个问题：一个length为n的字符串随机排列的可能性，第一个字母有n中可能，第二个字母有n-1种可能性，所以一共就是1到n的累加种可能性：n*(n+1)/24.计数法：自己写一个或者利用collections的Counter模块123456789101112131415161718192021def count(a,b): # 先建立两个含有26个0的列表用来计数每个字母出现了几次 l1 = [0] * 26 l2 = [0] * 26 for i in range(len(a)-1): # a 对应数字97，以a为基准 pos = ord(a.lower()[i]) - ord('a') l1[pos] += 1 for i in range(len(b)-1): pos = ord(b.lower()[i]) - ord('a') l2[pos] += 1 # 判断生成的两个列表是否一样 for i in range(27): if l1[i] != l2[i]: return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a, b)from collections import Counterif Counter(a.lower()) == Counter(b.lower()): print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b))print(count(a,b)) 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"glob文件操作","slug":"glob模块","date":"2020-07-28T08:02:57.792Z","updated":"2020-08-03T05:24:51.808Z","comments":true,"path":"2020/07/28/glob模块/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/glob%E6%A8%A1%E5%9D%97/","excerpt":"","text":"glob模块:查找文件和目录可使用的通配符： *匹配0或多个字符 ** 匹配所有文件,目录，子目录和子目录里面的文件 ？ 匹配一个字符,这里与正则表达式? (正则?匹配前面表达式0次或者1次) [] 匹配指定范围内的字符,如: [1-9]匹配1至9内的字符 [!] 匹配不在指定范围内的字符 查找当前路径下所有py文件：12for fname in glob.glob(\"**/*.py\",recursive=True): # recursive=True也查找子文件夹中的文件 print(fname) 当前路径文件tmp下py文件:12for fname in glob.glob(\"./tmp/*.py\"): print(fname) 当前路径文件下以file开头后有一个字符的py文件:12for fname in glob.glob(\"./file?.py\"): print(fname) 当前路径文件下以file开头后一个数字符的py文件:12for fname in glob.glob(\"./file[0-9].py\"): print(fname) 当前路径文件下以file开头后一个非数字符的py文件:12for fname in glob.glob(\"./file[!0-9].py\"): print(fname) 查询子目录：12for name in glob.glob('dir/*/*'): print ('\\t', name) glob模块iglob 返回iterator执行效率更高:当前路径文件tmp下py文件:12for fname in glob.iglob(\"./tmp/*.py\"): print(fname) ## 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"}]},{"title":"python statistics模块","slug":"python数学统计","date":"2020-07-28T06:11:27.486Z","updated":"2020-08-03T05:24:51.818Z","comments":true,"path":"2020/07/28/python数学统计/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/python%E6%95%B0%E5%AD%A6%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"统计模块statistics statistics.mean(data) ：平均值，可输入列表，含小数的decimal statistics.harmonic_mean(data): 调和平均数(倒数平均数) statistics.median(data)： 中值 median([1, 3, 5, 7]) =&gt; 4 statistics.median_low(data)：小中值 median_low([1, 3, 5, 7]) =&gt; 3 statistics.median_high(data)：大中值 median_low([1, 3, 5, 7]) =&gt; 5 statistics.median_grouped(data, interval=1)：用组距式来求中位数 statistics.mode(data): 众数 statistics.pstdev(data, mu=None): 总体标准差 statistics.pvariance(data, mu=None): 总体方差 statistics.stdev(data, xbar=None): 样本标准差 statistics.variance(data, xbar=None): 样本方差 总体方差的分母却是n。样本方差的分母是n-1。 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"javascript原型链","slug":"js原型链","date":"2020-07-28T06:06:51.928Z","updated":"2020-08-03T05:24:51.777Z","comments":true,"path":"2020/07/28/js原型链/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/js%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"javascript原型原型链：每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。概念： prototype:每一个函数都有这个属性，指向函数的原型对象； __proto__:每一个 new 出来的对象都有这个属性，指向这个对象的原型(prototype )； constructor:每一个原型都有一个constructor属性，指向关联的构造函数 关键：原型对象也是一个对象，也有自己的\\proto__属性，所以就形成了继承链。相关： 在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。 ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数： 123456var a = &#123;a: 1&#125;; // a ---&gt; Object.prototype ---&gt; null var b = Object.create(a);// b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.a); //b的原型对象就是a javascript是没有真正意义上的类的，所谓的类就是基于原型链和继承来实现的，即使ES6中加入了class,extends关键字实现类和继承，但实际上还是基于原型链和继承， ES6 类（class）是 JavaScript 现有的原型继承的语法糖。 实际上在定义一个对象的时候原型链本身就已经生成了，javascript处处皆对象的思想放在这里理解起来就很容易了，看完后你会发现万物始于Object.prototype。 ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 class, constructor, static, extends, 和 super. 语法糖就相当于汉语里的成语。即，用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率。 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"}]},{"title":"jQuery的引入","slug":"jQuery","date":"2020-07-28T06:01:33.445Z","updated":"2020-08-03T05:24:51.838Z","comments":true,"path":"2020/07/28/jQuery/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/jQuery/","excerpt":"","text":"jQuery 引入jQuery1234路径引入&lt;script src='文件路径'&gt;&lt;/script&gt;引入在线资源&lt;script src = \"https://code.jquery.com/jquery-1.12.4.js\"&gt;&lt;/script&gt; 入口函数123456$(document).ready(function()&#123; //类似于原生js的window.onload&#125;);//简写$(function()&#123; &#125;); 实例 12345678$(\"td\").hover( function () &#123; $(this).addClass(\"hover\"); &#125;, function () &#123; $(this).removeClass(\"hover\"); &#125;); 原创不易，转载请注明出处：gaoxzblog.top/","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/JavaScript/"},{"name":"C++","slug":"C","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/C/"},{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"C++","slug":"C","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/C/"},{"name":"水仙花数","slug":"水仙花数","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"魔法方法","slug":"魔法方法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"}]}