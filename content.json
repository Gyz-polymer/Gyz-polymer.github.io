{"meta":{"title":"Gxzblog","subtitle":"python advance","description":"Life is short, I enjoy python.","author":"Gxzblog","url":"https://github.com/Gyz-polymer/Gyz-polymer.github.io","root":"/Gyz-polymer.github.io/"},"pages":[],"posts":[{"title":"队列 Queue","slug":"队列Queue","date":"2020-07-30T03:01:20.803Z","updated":"2020-07-30T03:03:57.099Z","comments":true,"path":"2020/07/30/队列Queue/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/30/%E9%98%9F%E5%88%97Queue/","excerpt":"","text":"队列dequedeque是一种线性数据结构，具有先进先出First In First Out,后进后出的特点。只允许一头进(添加操作)–顶端，另一头出(移除操作)–底端。 队列：生活中排队买东西，先来的先买，后到的后买 用python实现队列： 用列表实现队列，队列的尾部在列表头部，队列头部在列表尾部 12345678910111213141516&gt;class Queue: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.insert(0,item) def dequeue(self): return self.items.pop() def size(self): return len(self.items) &gt;q = Queue()&gt;print(q.isEmpty()) # True&gt;q.enqueue('bobby')&gt;print(q.isEmpty()) # False 用列表实现队列，队列的头部在列表头部，队列尾部在列表尾部 1234567891011class QueueLeft: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0) def size(self): return len(self.items) 应用：约瑟夫问题一个游戏：每隔几个人移除一个人，如每数到7去掉一人 1234567891011121314def CountNum(nameArr,num): qu = Queue() for name in nameArr: # 在队列中名字顺序反过来了，刚好因为出栈顺序是先进先出 qu.enqueue(name) # 如果队列中人数多余一人，继续移除 while qu.size() &gt; 1: for i in range(num): # 移除队列的人马上从另一端重新加入队列 qu.enqueue(qu.dequeue()) # 每个num个人移除一个 qu.dequeue() return qu.dequeue()print(CountNum(['a','b','v','d','f','h','w','k','l','o','q'],7)) #out:l 文档参考自《python数据结构与算法分析(第2版)》","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈 Stack","slug":"栈Stack","date":"2020-07-29T14:05:11.206Z","updated":"2020-07-30T03:01:57.928Z","comments":true,"path":"2020/07/29/栈Stack/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/%E6%A0%88Stack/","excerpt":"","text":"栈stackstack是一种数据结构，具有先进后出First In Last Out,后进先出的特点。只允许一头进出(添加操作)–顶端，(移除操作)–顶端，底端不发生变化。 就像在自助餐厅的一摞盘子，最上面的盘子是最后加上去的，但是总是最先被取走使用，这就是后进先出。 栈操作：❏ push(item)将一个元素添加到栈的顶端。它需要一个参数item，且无返回值。❏ pop()将栈顶端的元素移除。它不需要参数，但会返回顶端的元素，并且修改栈的内容。❏ peek()返回栈顶端的元素，但是并不移除该元素。它不需要参数，也不会修改栈的内容。❏ isEmpty()检查栈是否为空。它不需要参数，且会返回一个布尔值。❏ size()返回栈中元素的数目。它不需要参数，且会返回一个整数。利用python实现栈： 利用列表，假设列表的尾部是栈的头部 1234567891011121314151617181920212223242526272829# 实现栈Last In first Out的功能：push，pop,peek,isEmpty,size()# 用列表实现，假设列表的尾部是栈的顶端class Stack: def __init__(self): self.items = [] # 判断栈是不是空的 def isEmpty(self): return self.items == [] # 将元素添加到栈的顶端 def push(self,item): self.items.append(item) # 时间复杂度O(1) # 将元素从栈的顶端移除 def pop(self): return self.items.pop() # 时间复杂度O(1) # 返回栈顶端的数据 def peek(self): return self.items[len(self.items)-1] # 返回栈的大小 def size(self): return len(self.items)s1 = Stack()print(s1.isEmpty())s1.push(1)print(s1.isEmpty())s1.push(2)print(s1.peek())print(s1.size())print(s1.items) 利用列表，假设列表的头部是栈的头部 123456789101112131415161718class StackRight: def __init__(self): self.items = [] # 判断栈是不是空的 def isEmpty(self): return self.items == [] # 将元素添加到栈的顶端 def push(self,item): self.items.insert(0,item) # 时间复杂度O(n) # 将元素从栈的顶端移除 def pop(self): return self.items.pop(0) # 时间复杂度O(n) # 返回栈顶端的数据 def peek(self): return self.items[0] # 返回栈的大小 def size(self): return len(self.items) 应用：栈先进后出的特点有很多巧妙的应用 1.判断符号的匹配，python种表示[]列表，()表示元组，{}表示字典或集合，这些符号都是可以复用的，组合使用，如{[()()&lt;&gt;()]}是一个符合匹配的形式，而([)]，{([}不不符合匹配。利用栈可以判断是否符合匹配 12345678910111213141516171819202122232425262728# 利用上面列表的尾部是栈的顶端---第一种方法实现栈def parChecker(pars): s = Stack() balanced = True index = 0 while index &lt; len(pars) and balanced: par = pars[index] if par in '&lt;(&#123;[': s.push(par) else: if s.isEmpty(): # 说明closed的符号多了 balanced = False else: top = s.pop() # 获得弹出的符号 if not matches(top, par): # 判断弹出符号与当前的是否匹配 balanced = False index += 1 if balanced and s.isEmpty(): return True else: return Falsedef matches(start,close): # 判断是否匹配 starts = '&lt;(&#123;[' closes = '&gt;)&#125;]' # index获取字符再字符串中的位置 return starts.index(start) == closes.index(close)print(parChecker('&#123;[()()&lt;&gt;()]&#125;')) # out:Trueprint(parChecker('&#123;[()(&lt;&gt;()]&#125;')) # out:False 2.进制转换：十进制转换为二进制，一般转化成二进制是通过除以2的方法实现。 ​ 算法实现： 1234567891011121314# 利用上面列表的尾部是栈的顶端---第一种方法实现栈def divideBy2(decNumber): # c参数是十进制数字 remStack = Stack() while decNumber &gt; 0: rem = decNumber % 2 # 取余数并推入到栈里 remStack.push(rem) decNumber = decNumber // 2 binString = '' while not remStack.isEmpty(): binString = binString + str(remStack.pop()) # 从栈中弹出一位数添加到字符串中 return binStringprint(divideBy2(16)) #out:10000print(divideBy2(17)) #out:10001 ​ 进一步：实现多种进制的转换 1234567891011121314def divideByBase(decNumber,base): # base为要转化为的进制 # 创建一套可以表示16进制的字符 digits = '0123456789ABCDEF' remStack = Stack() while decNumber &gt; 0: rem = decNumber % base # 取余数作为最后一位 remStack.push(rem) decNumber = decNumber // base baseString = '' while not remStack.isEmpty(): baseString = baseString + str(remStack.pop()) return baseStringprint(divideByBase(16,16)) #转化为16进制，10print(divideByBase(32,8)) # 转化为8进制，40 3.中序，前序，后续表达式转换 对于A+B×C+D人类可以根据运算符优先级进行步骤计算：先算括号，再算乘除，最后加减。但是计算机并不认识加减乘除，必须加上括号才能识别优先级，前面的优先级就要写成：(A+(B×C)+D)，平白多了两对括号，为了解决这个问题就引入了前序和后续表达式，如下所示： 中序表达式 前序表达式 后序表达式 A + B + A B A B + A + B × C + A * B C A B C * + 若要将任意复杂的中序表达式转换成前序表达式或后序表达式，可以先将其写作完全括号表达式，然后将括号内的运算符移到左括号处（前序表达式）或者右括号处（后序表达式）。 只有中序表达式需要额外的符号来消除歧义。前序表达式和后序表达式的运算顺序完全由运算符的位置决定。鉴于此，中序表达式是最不理想的算式表达法。 算法实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 将中序表达式转化为后序表达式import stringdef infixToPostfix(infixexpr): # infixexpr：输入的表达式字符之间一定要有空格 prec = &#123;&#125; # 用数字表示运算符的优先级 prec['*'] = 3 prec['/'] = 3 prec['+'] = 2 prec['-'] = 2 prec['('] = 1 # 用于保存输入表达式中的所有运算符 newStack = Stack() # 列表保存结果：生成后续表达式 postFixList = [] # 将输入的表达式通过空格转换成列表 tokenList = infixexpr.split() #检查输入的表达式是否符合每个字符间有空格 for token in tokenList: if len(token) != 1: return '输入的表达式字符之间缺少空格...' # 对生成的列表逐个扫描 for token in tokenList: # 用所有大写字母表示表达式中所有可以出现的操作数 if token in string.ascii_uppercase: # 如果是操作数(A,B,C...)就加到列表末尾 postFixList.append(token) # 如果是左括号就压入栈 elif token == '(': newStack.push(token) # 如果是右括号就弹出栈，直到找到与之对应的左括号 elif token == ')': topToken = newStack.pop() while topToken != '(': # 把从栈中取出来的运算符都添加到列表末尾 postFixList.append(topToken) topToken = newStack.pop() # 如果是其他运算符 * / + - 就把运算符压入栈 else: # 压入之前，先判断：如果栈中的运算符优先于输入的运算符，就把栈中的运算符添加到列表末尾 while (not newStack.isEmpty()) and (prec[newStack.peek()] &gt;= prec[token]): postFixList.append(newStack.pop()) newStack.push(token) # 处理完所有输入后，将栈中残留的运算符全部添加到列表末尾 while not newStack.isEmpty(): postFixList.append(newStack.pop()) # 把列表变成字符串 return ' '.join(postFixList)print(infixToPostfix('A + B * C')) #out: A B C * +# 在A与+之间删除空格print(infixToPostfix('A+ B * C')) #out: 输入的表达式字符之间缺少空格... 参考文献《python数据结构与算法分析(第2版)》","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"垃圾回收和缓存机制","slug":"python垃圾回收和缓存机制","date":"2020-07-29T08:42:04.290Z","updated":"2020-07-29T08:50:38.817Z","comments":true,"path":"2020/07/29/python垃圾回收和缓存机制/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"垃圾回收机制一句话python垃圾回收：以引用计数为主，标记清除和分代回收为辅。引用计数器环状双向链表：refchain—-python中创建的任意对象，都会加到refchain的双向链表中—包含了所有的python对象 针对代码name = &#39;bobby&#39;, c语言会创建如下4个数据： 上一个对象的指针 *_ob_prev和下一个对象的指针 *_ob_next(_Py_HEAD_EXTRA)—双向查找 数据的类型 ob_refcnt：如int,str,float等 ``引用计数 *ob_type。此时引用计数是1，如果再让new = name,则引用计数变为2。每一个对象都有至少这四个值,这四个值存放在结构体PyObject` 里。 由多个元素组成的对象，如字典，列表，集合等还有一个值ob_size，用来存储数据大大小(元素的个数)。 除PyObject之外，Python中另一个重要的是PyVarObject了，它是变长对象，例如List、String，显然PyObject无法满足它们需求，所以就需要用到PyVarObject了，实际上，PyVarObject与PyObject相比只多了一个属性ob_size，它指明了变成对象中有多少个元素（不是字节数） c++中两个重要的结构体：PyObject 和PyVarObject就是上述这个作用。 举例：创建一个float的内部实现 12345678data = 3.14# 内部会创建_ob_next = refchain的下一个对象_ob_prev = refchain的上一个对象ob_refcnt = 1 # 默认是1，当有其他变量引用时，引用计数发送变化 del则减一，当引用为0时则进行对象回收ob_type = floatob_fval = 3.14# 回收：将对象从refchain中移除，将对象进行销毁，归还对象所占用的内存 python会根据数据类型的不同，找到其对应的结构体，根据结构体中的字段来创建相关的数据，然后将对象添加到refchain双向链表中。当引用为0时就当成垃圾删除 引用计数器的bug：循环引用12345678t1 = [1,2,3] #refchain创建一个列表，列表的引用计数为1t2 = [4,5,6] #refchain再创建一个列表，列表的引用计数为1t1.append(t2) # t2被追加到t1，则t2对应的对象[4,5,6]的引用计数器加1，变为2t2.append(t1) # t1被追加到t2，则v1对应的对象[1,2,3]的引用计数器加1，变为2del t1 # 引用计数器-1，还是1，无法回收del t2 # 引用计数器-1，还是1，无法回收# 但是，此时没有变量指向[1,2,3]和[4,5,6]这两个列表了，变成一直存在于内存中的垃圾 标记清除目的：解决循环引用实现：再python底层再维护一个链表，在链表中专门放那些可能存在循环引用的对象(能存放其他对象的对象)，如list,dict,tuple,set等。 在python内部某种情况下区扫描这个可能循环引用的链表，检查是否有循环引用，如果有就让双方的引用计数器都减1，如果计数器是0就垃圾回收。 因此，python就有了两个链表。 问题来了： 什么时候扫描？ 扫描的代价：每次不仅要扫描可能有循环引用的对象，还要扫描其子元素是否有循环引用 扫描的代价很大，每次全部扫描成本很高，频繁扫描严重消耗性能，所以引入了对象分代机制。 分代回收实现：将可能存在循环引用的对象维护成3个链表： 0代链表：规定0代中对象个数达到700个就扫描1次。 1代链表：规定0代扫描10次，1代扫描1次。 2代链表：规定1代扫描10次，2代扫描1次。 最开始可能有循环引用的对象都将添加到0代，直到达到了700个，就进行1次扫描，如果有循环引用就计数器都减1，回收垃圾，如果没有，接下来的对象就添加到1代链表,如果再满了，就加到2代链表。 缓存机制池为了避免重复去创建和销毁常见对象，将常见对象(int,str)放在了一个池里，也就是说池里的对象永远不会被回收。 1234567# python内部会创建从-5到257的值，放在池里，所以创建t1 = 3时，不会重新开辟内存，直接从池里拿# int的数据池也被称为小数据池small_intst1 = 3t2 = 6t3 = 3 #t3和t1指向的内存地址一模一样--id(t3) == id(t1)t4 = 300 # 会重新创建对象t5 = 300 # 也会重新创建对象,t5与t4内存地址不同--id(t4) != id(t5) 对于字符串str类型，内部将所有的ASCII字符缓存到了unicode_latin[256]链表中，以后不用再反复创建。 12345s1 = 'C'print(s1) #out:1343834377264del s1s2 = 'C'print(s2) #out:1343834377264 s1和s2用的是同一个id地址 字符串驻留机制：对于只有字符，数字，下划线且长度不大于20的字符串，会缓存到内存中，再次创建一模一样的字符串时，不会再次开辟内存，而是直接从内存中取出来。 12345s1 = 'abcde'print(id(s1)) #out:1996598711216del s1s2 = 'abcde'print(id(s2)) #out:1996598711216 free_list链表当一个对象(float,list,dict,tuple)的引用计数器为0时，按理说应该回收，但内部不直接回收，而是放到free_list链表中当作缓存，下次再创建相同类型的对象时就不用重新开辟内存了，而是直接使用free_list链表。 1234pie = 3.14 # 创建float类型对象，开辟内存，添加到refchain中del pie # 从refchain移除，添加到free_list中# 再次创建float类型t2 = 6.88 # 不会重新开辟内存，从free_list中获取对象，对象数据初始化再放到refchain中。 但是不是所以数据都缓存到free_list中，而是有数量限制，假设只能放100个对象，超过了100就会删除最先添加的对象。","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"判断异序字符串","slug":"判断异序字符串","date":"2020-07-29T04:00:31.367Z","updated":"2020-07-29T04:06:05.343Z","comments":true,"path":"2020/07/29/判断异序字符串/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/29/%E5%88%A4%E6%96%AD%E5%BC%82%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"需求判断两个单词是不是异序词，判断时忽略大小写，例如earth和heart就是异序词。以如下两个随便写的字符串为例，进行判断：12a = 'adceWq'b = 'aCedqw' 1.利用内置函数sorted：先判断长度，字母都变成小写，进行排序判断 – O(n^2^)123456def sort_word(a,b): if len(a) == len(b) and sorted(a.lower()) == sorted(b.lower()): return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b) else: return 'No...'print(sort_word(a,b)) 2.清点法：将a的每一个字母添加到一个列表,如果b某一个字母不在a里面那就是不同字母 –O(n^2^)12345678def justify(a,b): if len(a) == len(b): for i in b.lower(): if i not in list(a.lower()): return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)print(justify(a,b)) 3.蛮力法：将a生成所有的可能的字符串列表，看b是不是在里面—特别慢 O(n!)123456c = [[b1,b2,b3,b4,b5,b6] for b1 in a.lower() for b2 in a.lower().replace(b1,'') for b3 in a.lower().replace(b1,'').replace(b2,'') for b4 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'') for b5 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'') for b6 in a.lower().replace(b1,'').replace(b2,'').replace(b3,'').replace(b4,'').replace(b5,'')]# print(c)if list(b.lower()) in c: print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b)) 本来要将上面的方法简化一下，写成函数，函数恐怕也只能迭代了，迭代的速度也很低，没找到好方法，欢迎大家提供，这个方法其实是把问题变成了另一个问题：一个length为n的字符串随机排列的可能性，第一个字母有n中可能，第二个字母有n-1种可能性，所以一共就是1到n的累加种可能性：n*(n+1)/24.计数法：自己写一个或者利用collections的Counter模块123456789101112131415161718192021def count(a,b): # 先建立两个含有26个0的列表用来计数每个字母出现了几次 l1 = [0] * 26 l2 = [0] * 26 for i in range(len(a)-1): # a 对应数字97，以a为基准 pos = ord(a.lower()[i]) - ord('a') l1[pos] += 1 for i in range(len(b)-1): pos = ord(b.lower()[i]) - ord('a') l2[pos] += 1 # 判断生成的两个列表是否一样 for i in range(27): if l1[i] != l2[i]: return 'No...' else: return '&#123;&#125; and &#123;&#125; is the words with different order.'.format(a, b)from collections import Counterif Counter(a.lower()) == Counter(b.lower()): print('&#123;&#125; and &#123;&#125; is the words with different order.'.format(a,b))print(count(a,b))","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"glob文件操作","slug":"glob模块","date":"2020-07-28T08:02:57.792Z","updated":"2020-07-28T08:04:42.130Z","comments":true,"path":"2020/07/28/glob模块/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/glob%E6%A8%A1%E5%9D%97/","excerpt":"","text":"glob模块:查找文件和目录可使用的通配符： *匹配0或多个字符 ** 匹配所有文件,目录，子目录和子目录里面的文件 ？ 匹配一个字符,这里与正则表达式? (正则?匹配前面表达式0次或者1次) [] 匹配指定范围内的字符,如: [1-9]匹配1至9内的字符 [!] 匹配不在指定范围内的字符 查找当前路径下所有py文件：12for fname in glob.glob(\"**/*.py\",recursive=True): # recursive=True也查找子文件夹中的文件 print(fname) 当前路径文件tmp下py文件:12for fname in glob.glob(\"./tmp/*.py\"): print(fname) 当前路径文件下以file开头后有一个字符的py文件:12for fname in glob.glob(\"./file?.py\"): print(fname) 当前路径文件下以file开头后一个数字符的py文件:12for fname in glob.glob(\"./file[0-9].py\"): print(fname) 当前路径文件下以file开头后一个非数字符的py文件:12for fname in glob.glob(\"./file[!0-9].py\"): print(fname) 查询子目录：12for name in glob.glob('dir/*/*'): print ('\\t', name) glob模块iglob 返回iterator执行效率更高:当前路径文件tmp下py文件:12for fname in glob.iglob(\"./tmp/*.py\"): print(fname)","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"}]},{"title":"python statistics模块","slug":"python数学统计","date":"2020-07-28T06:11:27.486Z","updated":"2020-07-28T06:12:12.085Z","comments":true,"path":"2020/07/28/python数学统计/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/python%E6%95%B0%E5%AD%A6%E7%BB%9F%E8%AE%A1/","excerpt":"","text":"统计模块statistics statistics.mean(data) ：平均值，可输入列表，含小数的decimal statistics.harmonic_mean(data): 调和平均数(倒数平均数) statistics.median(data)： 中值 median([1, 3, 5, 7]) =&gt; 4 statistics.median_low(data)：小中值 median_low([1, 3, 5, 7]) =&gt; 3 statistics.median_high(data)：大中值 median_low([1, 3, 5, 7]) =&gt; 5 statistics.median_grouped(data, interval=1)：用组距式来求中位数 statistics.mode(data): 众数 statistics.pstdev(data, mu=None): 总体标准差 statistics.pvariance(data, mu=None): 总体方差 statistics.stdev(data, xbar=None): 样本标准差 statistics.variance(data, xbar=None): 样本方差 总体方差的分母却是n。样本方差的分母是n-1。","categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"}]},{"title":"javascript原型链","slug":"js原型链","date":"2020-07-28T06:06:51.928Z","updated":"2020-07-28T10:04:19.310Z","comments":true,"path":"2020/07/28/js原型链/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/js%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"javascript原型原型链：每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。概念： prototype:每一个函数都有这个属性，指向函数的原型对象； __proto__:每一个 new 出来的对象都有这个属性，指向这个对象的原型(prototype )； constructor:每一个原型都有一个constructor属性，指向关联的构造函数 关键：原型对象也是一个对象，也有自己的\\proto__属性，所以就形成了继承链。相关： 在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。 ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数： 123456var a = &#123;a: 1&#125;; // a ---&gt; Object.prototype ---&gt; null var b = Object.create(a);// b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.a); //b的原型对象就是a javascript是没有真正意义上的类的，所谓的类就是基于原型链和继承来实现的，即使ES6中加入了class,extends关键字实现类和继承，但实际上还是基于原型链和继承， ES6 类（class）是 JavaScript 现有的原型继承的语法糖。 实际上在定义一个对象的时候原型链本身就已经生成了，javascript处处皆对象的思想放在这里理解起来就很容易了，看完后你会发现万物始于Object.prototype。 ECMAScript6 引入了一套新的关键字用来实现 class。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不一样的。 JavaScript 仍然是基于原型的。这些新的关键字包括 class, constructor, static, extends, 和 super. 语法糖就相当于汉语里的成语。即，用更简练的言语表达较复杂的含义。在得到广泛接受的情况之下，可以提升交流的效率。","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"}]},{"title":"jQuery的引入","slug":"jQuery","date":"2020-07-28T06:01:33.445Z","updated":"2020-07-28T06:04:04.835Z","comments":true,"path":"2020/07/28/jQuery/","link":"","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/2020/07/28/jQuery/","excerpt":"","text":"jQuery 引入jQuery1234路径引入&lt;script src='文件路径'&gt;&lt;/script&gt;引入在线资源&lt;script src = \"https://code.jquery.com/jquery-1.12.4.js\"&gt;&lt;/script&gt; 入口函数123456$(document).ready(function()&#123; //类似于原生js的window.onload&#125;);//简写$(function()&#123; &#125;); 实例 12345678$(\"td\").hover( function () &#123; $(this).addClass(\"hover\"); &#125;, function () &#123; $(this).removeClass(\"hover\"); &#125;);","categories":[{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/python/"},{"name":"javacript","slug":"javacript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/"},{"name":"jQuery","slug":"javacript/jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/categories/javacript/jQuery/"}],"tags":[{"name":"python","slug":"python","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"办公自动化","slug":"办公自动化","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E5%8A%9E%E5%85%AC%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"文件处理","slug":"文件处理","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://github.com/Gyz-polymer/Gyz-polymer.github.io/tags/jQuery/"}]}